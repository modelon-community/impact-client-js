/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** Type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/": {
    /**
     * Returns an object with meta data for this API 
     * @description Can be used by client to check that the API is of a version it supports. The APIs version is semantic.
     */
    get: operations["getAPIMetaData"];
  };
  "/login": {
    /**
     * Logs in a user 
     * @description When the login succeeds, the response includes a cookie containing an access token which is used for further identification with the REST API. The login is managed by a third party authorization service. To authenticate against the REST API, an API key may be included in the optional request body. The API key can be created <a class="visible-link" href="/admin/keys">in the API key manager</a>.
     */
    post: operations["login"];
  };
  "/projects": {
    /**
     * Get all projects 
     * @description Returns a list of all local projects that exists. The query parameter vcsInfo can be used to also get info on how projects are version controlled.
     */
    get: operations["getProjects"];
    parameters?: {
        /**
         * @description If true, returned projects vcsUri field will be set if the project is version controlled. If false, vscUri will not be set for any returned project. Default is false. 
         * @example vcsInfo=true
         */
        /**
         * @description Used to filter so only projects of a specified projectType is returned. If not given all project types are returned. 
         * @example type=RELEASED
         */
      query?: {
        vcsInfo?: string;
        type?: string;
      };
    };
  };
  "/project-imports": {
    /**
     * Start import of a project 
     * @description Will initiate import of a project. After a successful completion of a call to this endpoint, call GET /project-imports/{importId} to check status.
     */
    post: operations["importProject"];
  };
  "/project-imports/{importId}": {
    /**
     * Returns status for a project import. Also returns data for the imported resource when ready 
     * @description The project needs to be setup for import by calling POST /project-imports, before calling this API endpoint.
     */
    get: operations["importProjectStatus"];
    /**
     * Deletes a project import 
     * @description This API end point can be be called after a project has been imported.
     */
    delete: operations["deleteProjectImport"];
    parameters: {
        /**
         * @description ID of the project import to check status on. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        importId: string;
      };
    };
  };
  "/project-exports": {
    /**
     * Prepares a project for download as a zip file 
     * @description The compressed project will be prepared. After a successful completion of a call to this endpoint, call GET /project-exports/{exportId} to check status.
     */
    post: operations["prepareExportProjectAsync"];
  };
  "/project-exports/{exportId}": {
    /**
     * Returns status for preparing a project for download. Also returns data for download when ready 
     * @description The project needs to be setup for export by calling POST /project-exports, before calling this API endpoint.
     */
    get: operations["exportProjectAsync"];
    /**
     * Deletes a project export, including the compressed zip 
     * @description This API end point can be be called after a compressed project has been downloaded.
     */
    delete: operations["deleteExportedProjectAsync"];
    parameters: {
        /**
         * @description ID of the compressed project to check status on. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        exportId: string;
      };
    };
  };
  "/projects/{project}": {
    /**
     * Get a project 
     * @description Returns a project given a project ID. The query parameter vcsInfo can be used to also get info on how the project is version controlled.
     */
    get: operations["getProject"];
    /**
     * Update a project 
     * @description Updates a project given project data and a project ID. Only the project definition is allowed to be updated and content entries cannot be added or deleted. Content ID or project format cannot be updated.
     */
    put: operations["updateProject"];
    /**
     * Delete a project 
     * @description Deletes a project given a project ID. Will also delete any reference from workspaces to this project.
     */
    delete: operations["deleteProject"];
    parameters: {
        /**
         * @description ID of the project the content is imported into. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        project: string;
      };
    };
  };
  "/projects/{project}/content": {
    /**
     * Create new content entry 
     * @description Will create a new content entry for a project. For MODELICA content entries an empty structured modelica library will also be created on disk.
     */
    post: operations["createContent"];
    parameters: {
        /**
         * @description ID of the project the content is created in. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        project: string;
      };
    };
  };
  "/projects/{project}/content/{content}": {
    /**
     * Get a content entry 
     * @description Returns a content entry given project and content IDs.
     */
    get: operations["getContent"];
    /**
     * Delete a content entry 
     * @description Deletes a content entry from a project. Any files on disk that exists for this content is also deleted.
     */
    delete: operations["deleteContent"];
    parameters: {
        /**
         * @description ID of the project the content is defined in. 
         * @example 79sd8-3n2a4-e3t24
         */
        /**
         * @description ID of the content entry. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        project: string;
        content: string;
      };
    };
  };
  "/projects/{project}/content-imports": {
    /**
     * Start import of existing content 
     * @description Will initiate import of existing content. After a successful completion of a call to this endpoint, call GET /projects/{project}/content-imports/{importId} to check status.
     */
    post: operations["importContent"];
    parameters: {
        /**
         * @description ID of the project the content is imported into. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        project: string;
      };
    };
  };
  "/projects/{project}/content-imports/{importId}": {
    /**
     * Returns status for a content import. Also returns data for the imported resource when ready 
     * @description The content needs to be setup for import by calling POST /content-imports, before calling this API endpoint.
     */
    get: operations["importContentStatus"];
    /**
     * Deletes a content import 
     * @description This API end point can be be called after a content has been imported.
     */
    delete: operations["deleteContentImport"];
    parameters: {
        /**
         * @description ID of the project the content is imported into. 
         * @example 79sd8-3n2a4-e3t24
         */
        /**
         * @description ID of the content import to check status on. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        project: string;
        importId: string;
      };
    };
  };
  "/projects/{project}/content/{content}/fmu-imports": {
    /** Imports an co-simulation FMU */
    post: operations["importFMU"];
    parameters: {
        /**
         * @description ID of the project the content is defined in. 
         * @example 79sd8-3n2a4-e3t24
         */
        /**
         * @description ID of the content entry. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        project: string;
        content: string;
      };
    };
  };
  "/projects/{project}/content/{content}/fmu-imports/{importId}": {
    /**
     * Returns status for a FMU import. Also returns data for the imported resource when ready 
     * @description The content needs to be setup for import by calling POST /fmu-imports, before calling this API endpoint.
     */
    get: operations["importFMUStatus"];
    /**
     * Deletes a FMU import 
     * @description This API end point can be be called after a FMU has been imported.
     */
    delete: operations["deleteFMUImport"];
    parameters: {
        /**
         * @description ID of the project the content is defined in. 
         * @example 79sd8-3n2a4-e3t24
         */
        /**
         * @description ID of the content entry. 
         * @example 79sd8-3n2a4-e3t24
         */
        /**
         * @description ID of the content import to check status on. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        project: string;
        content: string;
        importId: string;
      };
    };
  };
  "/projects/{project}/custom-functions/{custom-function}/options": {
    /**
     * Gets the execution options 
     * @description Gets the (aggregated) options for a custom function. This includes: Project specific options, options configured as defaults for the application, default options specified in the custom function. For options specified on multiple levels, the value is taken primarily from the project specific options, secondarily from the application default options and in third hand from the custom function default options.
     */
    get: operations["getExecutionOptionsProjects"];
    /**
     * Sets execution option values 
     * @description The values for the options are saved for a specific custom function and project.
     */
    put: operations["putExecutionOptions"];
    parameters: {
        /**
         * @description ID of the project execution options are located in. 
         * @example 79sd8-3n2a4-e3t24
         */
        /**
         * @description Name of the custom function. 
         * @example steady state
         */
      path: {
        project: string;
        "custom-function": string;
      };
    };
  };
  "/projects/{project}/custom-functions/{custom-function}/default-options": {
    /**
     * Gets the default execution options 
     * @description Gets the application level default options for a custom function. This includes: Options configured as defaults for the application and default options specified in the custom function. For options specified on both levels, the value is taken from the application default options.
     */
    get: operations["getDefaultExecutionOptionsProjects"];
    parameters: {
        /**
         * @description ID of the project execution options are located in. 
         * @example 79sd8-3n2a4-e3t24
         */
        /**
         * @description Name of the custom function. 
         * @example steady state
         */
      path: {
        project: string;
        "custom-function": string;
      };
    };
  };
  "/workspace-template": {
    /**
     * Returns an object containing the template for the workspace. 
     * @description The response from this endpoint can be used as a template to create a new workspace by sending it as the request body for the POST /workspaces endpoint.
     */
    get: operations["getWorkspaceTemplate"];
  };
  "/workspaces": {
    /**
     * Returns an object containing a list of all available workspaces together with metadata 
     * @description The workspace ID in the returned object serve as unique IDs that can be used in other API calls to perform operations for a specific workspace.
     */
    get: operations["getWorkspaces"];
    /**
     * Creates or imports a new workspace 
     * @description Creates a new workspace with some name.
     */
    post: operations["createWorkspace"];
    /**
     * Deletes from the workspace collection 
     * @description Used when not a specific workspace should be deleted but rather all workspaces with some attribute.
     */
    delete: operations["deleteWorkspaces"];
  };
  "/workspaces/{workspace}": {
    /** Returns an object containing the metadata of the specified ID */
    get: operations["getWorkspaceId"];
    /**
     * Increase the timestamp of a cloned workspace 
     * @description Can be called periodically on a cloned workspace a client is working against. This will inform the system that this workspace is not inactive and may not be deleted.
     */
    put: operations["increaseClonedWorkspaceTimestamp"];
    /** Deletes a workspace with the specified ID */
    delete: operations["deleteWorkspace"];
    parameters: {
        /**
         * @description ID of the workspace. 
         * @example MyWorkspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/conversion-check": {
    /** Returns what conversions are needed for a workspace and what potential issues there are */
    get: operations["getWorkspaceConversionCheckId"];
    parameters: {
        /**
         * @description ID of the workspace. 
         * @example MyWorkspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/clone": {
    /**
     * Creates a clone of a workspace 
     * @description A created clone of a workspace is a temporary resource. It can be used executing some workload based on resources of a workspace without mutating or adding anything to it.
     */
    post: operations["cloneWorkspace"];
    parameters: {
        /**
         * @description ID of the workspace. 
         * @example MyWorkspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/dependencies": {
    /**
     * Get workspace dependencies 
     * @description Get workspace dependencies.
     */
    get: operations["getWorkspaceDependencies"];
    parameters: {
        /**
         * @description ID of the workspace. 
         * @example MyWorkspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/dependency-imports": {
    /**
     * Start import of a project and add it as a dependency to the workspace 
     * @description Will initiate import of a project and add it as a dependency to the workspace. After a successful completion of a call to this endpoint, call GET /workspaces/{workspace}/dependency-imports/{importId} to check status.
     */
    post: operations["importWorkspaceDependency"];
    parameters: {
        /**
         * @description ID of workspace the project will be added to as a dependency. 
         * @example MyWorkspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/dependency-imports/{importId}": {
    /**
     * Returns status for a dependency import. Also returns data for the imported resource when ready 
     * @description The project to be added as a dependency needs to be setup for import by calling POST /dependency-imports, before calling this API endpoint.
     */
    get: operations["importWorkspaceDependencyStatus"];
    /**
     * Deletes a workspace dependency import 
     * @description This API end point can be be called after a project has been imported and added as a workspace depenendency.
     */
    delete: operations["deleteWorkspaceDependencyImport"];
    parameters: {
        /**
         * @description ID of workspace the project will be added to as a dependency. 
         * @example MyWorkspace
         */
        /**
         * @description ID of the dependency import to check status on. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        workspace: string;
        importId: string;
      };
    };
  };
  "/workspaces/{workspace}/project-imports": {
    /**
     * Start import of an editable project to be added to the workspace 
     * @description Will initiate import of a project and add it to the workspace. After a successful completion of a call to this endpoint, call GET /workspaces/{workspace}/project-imports/{importId} to check status.
     */
    post: operations["importWorkspaceProject"];
    parameters: {
        /**
         * @description ID of workspace the editable project will be added to. 
         * @example MyWorkspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/project-imports/{importId}": {
    /**
     * Returns status for a project import. Also returns data for the imported resource when ready 
     * @description The editable project to be added to the workspace needs to be setup for import by calling POST /project-imports, before calling this API endpoint.
     */
    get: operations["importWorkspaceProjectStatus"];
    /**
     * Deletes a workspace project import 
     * @description This API end point can be be called after a project has been imported and added to the workspace.
     */
    delete: operations["deleteWorkspaceProjectImport"];
    parameters: {
        /**
         * @description ID of workspace the editable project will be added to. 
         * @example MyWorkspace
         */
        /**
         * @description ID of the editable project import to check status on. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        workspace: string;
        importId: string;
      };
    };
  };
  "/workspaces/{workspace}/projects": {
    /**
     * Get workspace projects 
     * @description Get workspace projects.
     */
    get: operations["getWorkspaceProjects"];
    parameters: {
        /**
         * @description ID of the workspace. 
         * @example MyWorkspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/projects/{project}/experiments": {
    /**
     * Get project generated experiments for a workspace. 
     * @description Get project generated experiments for a workspace.
     */
    get: operations["getWorkspaceProjectExperiments"];
    parameters: {
        /**
         * @description ID of the workspace. 
         * @example MyWorkspace
         */
        /**
         * @description Name of the project. 
         * @example MyProject
         */
      path: {
        workspace: string;
        project: string;
      };
    };
  };
  "/workspaces/{workspace}/projects/{project}/model-executables": {
    /**
     * Get project generated FMUs for a workspace. 
     * @description Get project generated FMUs for a workspace.
     */
    get: operations["getWorkspaceProjectFmus"];
    parameters: {
        /**
         * @description ID of the workspace. 
         * @example MyWorkspace
         */
        /**
         * @description Name of the project. 
         * @example MyProject
         */
      path: {
        workspace: string;
        project: string;
      };
    };
  };
  "/workspaces/{workspace}/sharing-definition": {
    /**
     * Returns a workspaces sharing defintion 
     * @description Will create a workspace definition that can be shared with other users. This requires that all projects used in the workspace is either version controlled or a released projcet. The 'strict' query parameter can be used to specify if the version control URIs are to specific commits or not. The end-point /workspace-imports is used to import a workspace based on the shared definition returned from this end-point.
     */
    get: operations["getWorkspaceSharingId"];
    parameters: {
        /**
         * @description If true, version control references will be to a specific commit. If false, version control references will not contain specific commit. Default is false. 
         * @example strict=true
         */
      query?: {
        strict?: string;
      };
        /**
         * @description ID of the workspace. 
         * @example MyWorkspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/custom-functions/{custom-function}": {
    /**
     * Get the custom function meta-data 
     * @description Gets the meta-data for a custom function describing which parameters the custom function accepts (read more about the response for details). Note that the system comes with default custom functions thar are always available. Furthermore, you can read more about custom functions and setting up the system with your own in the Modelon Impact help center.
     */
    get: operations["getCustomFunction"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description Name of the custom function. 
         * @example steady state
         */
      path: {
        workspace: string;
        "custom-function": string;
      };
    };
  };
  "/workspaces/{workspace}/custom-functions/{custom-function}/options": {
    /**
     * Gets the execution options 
     * @description Gets the (aggregated) options for a custom function. This includes: Workspace specific options, options configured as defaults for the application, default options specified in the custom function. For options specified on multiple levels, the value is taken primarily from the workspace specific options, secondarily from the application default options and in third hand from the custom function default options.
     */
    get: operations["getExecutionOptions"];
    /**
     * Sets execution option values 
     * @description The values for the options are saved for a specific custom function and workspace.
     */
    put: operations["putExecutionOptions"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description Name of the custom function. 
         * @example steady state
         */
      path: {
        workspace: string;
        "custom-function": string;
      };
    };
  };
  "/workspaces/{workspace}/custom-functions/{custom-function}/default-options": {
    /**
     * Gets the default execution options 
     * @description Gets the application level default options for a custom function. This includes: Options configured as defaults for the application and default options specified in the custom function. For options specified on both levels, the value is taken from the application default options.
     */
    get: operations["getDefaultExecutionOptions"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description Name of the custom function. 
         * @example steady state
         */
      path: {
        workspace: string;
        "custom-function": string;
      };
    };
  };
  "/workspaces/{workspace}/custom-functions": {
    /**
     * Get a list of custom functions meta-data 
     * @description Which custom functions that exists are useful when setting up an experiment using POST /workspaces/{workspace}/experiments. The name of a custom function is used for the field 'analysis_function' which specifies that it should be used for the experiment. The meta-data also describes which parameters each custom function accepts (read more about the response for details). Note that the system comes with default custom functions thar are always available. Furthermore, you can read more about custom functions and setting up the system with your own in the Modelon Impact help center.
     */
    get: operations["getCustomFunctions"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/options/units/conversions": {
    /** Returns the set of unit conversion factors */
    get: operations["getUnitConversionFactors"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables": {
    /** Returns all model executables input and run info */
    get: operations["getAllModelExecutableInfo"];
    /**
     * Sets up a model executable to be compiled 
     * @description The name of the model to be compiled is specified by the field 'class_name'. The remaining fields in the input are options for the compilation process. For a reference of what options can be used in the field 'compiler_options' and 'runtime_option' see the OCT User's Guide, which can be found in the Modelon Impact help center. If the FMU should be executed in Impact (rather than exported) it is recommended that 'fmi_target' is 'me', 'fmi_version' is '2.0' and 'platform' is 'auto'. If this end-point is called with the query parameter 'getCached' set to true, then a previously compiled model executable is returned, if such an FMU exists. To get a cached model executable (FMU) there must exists a successfully compiled model executable that was compiled with the same inputs as in the current call. Furthermore, if the Modelica model for which the FMU compilation is requested has been changed in a structural way, or at least one of its dependent models have changed, then a cached FMU will not be returned. Setting non-structural parameters and making graphical changes to the Modelica model will not break the cache for its compiled FMU.
     */
    post: operations["modelExecutableSetup"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/supported-platforms": {
    /**
     * Returns the supported platforms for FMU generation 
     * @description Can be used to find which values are supported for the field 'platform' when calling the POST method on '/workspaces/{workspace}/model-executables'.
     */
    get: operations["getFmuPlatforms"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}": {
    /** Returns the compilation input and run info */
    get: operations["getModelExecutableInfo"];
    /** Deletes the FMU with the specified ID */
    delete: operations["deleteModelExecutable"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description The FMU ID. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
      path: {
        workspace: string;
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}/compilation": {
    /** Get compilation status */
    get: operations["getCompilationStatus"];
    /**
     * Compiles a model 
     * @description First call POST /workspaces/{workspace}/model-executables to setup what should be compiled.
     */
    post: operations["modelExecutableCompile"];
    /** Cancel a running compilation */
    delete: operations["cancelCompilation"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description Reference ID to the model to be compiled. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
      path: {
        workspace: string;
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}/compilation/log": {
    /** Downloads the model executable compilation log */
    get: operations["downloadCompilationLog"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description Reference ID to the compiled model. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
      path: {
        workspace: string;
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}/binary": {
    /** Downloads an FMU binary that is compiled */
    get: operations["downloadCompiledFMU"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description Reference ID to the compiled model. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
      path: {
        workspace: string;
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}/steady-state-metadata": {
    /** Gets the FMU meta-data */
    post: operations["getFmuMeta"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description Reference ID to the compiled model. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
      path: {
        workspace: string;
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}/settable-parameters": {
    /**
     * Gets the parameters that can be set on the FMU 
     * @description Can be used to find what parameters are feasible to have as modifiers in an experiment.
     */
    get: operations["getFmuParameters"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description Reference ID to the compiled model. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
      path: {
        workspace: string;
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}/string-parameters-and-values": {
    /**
     * Gets parameters that have string values together with those values 
     * @description Gets a list of parameters whose values are strings and one list with respective value in order. Can be used when requiring string parameters that don't come with the result.
     */
    get: operations["getFmuStringParametersAndValues"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description Reference ID to the compiled model. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
      path: {
        workspace: string;
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments": {
    /** Get all experiments meta-data */
    get: operations["getAllExperimentInfo"];
    /**
     * Sets up an experiment for execution 
     * @description The required inputs for setting up a multi-execution experiment is either 'id' in 'base/model/fmu' OR 'className' in 'base/model/modelica', along with 'type' in 'base/analysis'. These can be obtained from POST /workspaces/{workspace}/model-executables and GET /workspaces/{workspace}/custom-functions respectively. The FMU 'id' specifies what FMU the experiment is based on, and analysis 'type' specifies what analysis custom function is used for each case of the experiment. Furthermore, experiments support multi-execution, i.e., batch computations where each case executes a custom function. Multi-execution experiments can be set up in two ways.
     * 
     * The first way to setup multi-execution experiments is to specify 'operators' for 'modifiers' which are applied to the base experiment. An example experiment for this could contain the 'modifiers': {'variables': {'x': 'range(1, 2, 3)'}}, which would result in a multi-execution experiment with three cases: x=1, x=1.5, and x=2. Note that if multiple 'operators' are used for different variables, the experiment will be expand to cases with all combinations of parametrizations, i.e., full factorial is used to expand the experiment. Here is a full example using the range operator to create cases:
     * 
     * <pre>
     * {
     *   "experiment": {
     *     "version": 2,
     *     "base": {
     *       "model": {
     *         "fmu": {
     *           "id": "workspace_pid_controller_20090615_134530_as86g32"
     *         }
     *       },
     *       "modifiers": {
     *         "variables": {
     *           "inertia1.J": "range(1, 2, 10)",
     *         }
     *       },
     *       "analysis": {
     *         "type": "dynamic",
     *         "parameters": {
     *           "start_time": 0,
     *           "final_time": 1
     *         }
     *       }
     *     }
     *   }
     * }
     * </pre>
     * 
     * The other way of defining an experiment is to specify 'extensions' to the 'base' definition, where each 'extension' is combined with 'base' to create a case. For example, an experiment with the 'extensions': [{'modifiers': {'variables': {'x': 1}}}, {'modifiers': {'variables': {'x': 1.5}}}, {'modifiers': {'variables': {'x': 2}}}], would result in the same multi-execution as above (if no modifiers are defined in 'base'). This way of creating cases gives more freedom to the client to set up a multi-execution experiment, since cases are defined by parameter configurations, as opposed to operators (like the range operator). This approach also allows different options and custom function parameters to be used for the different cases. These two methods of setting up a multi-execution cannot be combined. So, if any extensions are given, it is not allowed to include any 'operators' anywhere in the experiment. It is however allowed to provide parameter values (with no operators) in 'base' in combination with defining cases with 'extensions'. In this case, parameters set in 'extensions' overrides those set in 'base'.
     * 
     * The following example shows how 'extensions' are used to set options and parameters for separate cases and thereby overriding the values in the 'base' definition. The 'base' definition in the example have 'analysis': {'type': 'dynamic', 'parameters': {'start_time': 2, 'final_time': 3}}, and 'modifiers': {'variables': {'x': 1, 'y': 3}}}. If used with the 'extensions':
     * 
     * [{'analysis': {'parameters': {'final_time': 4}}}, 'modifiers': {'variables': {'y': 5}}}, {'analysis': {'parameters': {'start_time': 1}}}, 'modifiers': {'variables': {'x': 2}}}],
     * 
     * we will get two cases. The first case will use 2 for 'start_time' from the 'base' and 4 for 'final_time' as it is overridden by the 'extension', in the same way it will use 'x'=1 and 'y'=5 as modifiers. The second case overrides 'start_time' and 'x' and will result in 'start_time'=1, 'final_time'=3, 'x'=2, and 'y'=3.
     * 
     * The old (version 1) experiment format can still be used but will be removed in a future version.
     */
    post: operations["setupExperiment"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
      path: {
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}": {
    /** Get experiment information */
    get: operations["getExperimentInfo"];
    /**
     * Set a label for an experiment 
     * @description Can be used to set a human readable identifier for an experiment.
     */
    put: operations["setLabel"];
    /** Removes an experiment */
    delete: operations["removeExperiment"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description The ID of the experiment. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
      path: {
        workspace: string;
        experimentId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/execution": {
    /** Get execution status */
    get: operations["getExecutionStatus"];
    /**
     * Executes an experiment 
     * @description First call POST /workspaces/{workspace}/experiments to setup what should be executed.
     */
    post: operations["execute"];
    /** Cancel a running execution */
    delete: operations["cancelExecution"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description The ID of the experiment. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
      path: {
        workspace: string;
        experimentId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/cases": {
    /** Get all cases meta-data */
    get: operations["getAllCaseInfo"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description The ID of the experiment. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
      path: {
        workspace: string;
        experimentId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/cases/{caseId}": {
    /** Get case information */
    get: operations["getCaseInfo"];
    /**
     * Update case information 
     * @description This end-point can be used to update a case input. This can be used to modify the case and then execute the case again as part of an experiment and get different results for the case. Only fields under 'input' and 'meta' can be updated. Also, the fields 'fmu_id', 'analysis_function', 'structural_parametrization' and 'fmu_base_parametrization' cannot be updated. After a case is updated the 'consistent' field will be set to 'false' to signify that case results might not match the case input. Executing the case as part of an experiment will set 'consistent' to 'true'. The recomended way to update the case is to first use the corresponding GET end-point, modify some data, then call PUT (this end-point) with that data.
     */
    put: operations["putCaseInfo"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description The ID of the experiment. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
        /**
         * @description The ID of the case. 
         * @example case_1
         */
      path: {
        workspace: string;
        experimentId: string;
        caseId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/cases/{caseId}/log": {
    /** Get the log for a finished case */
    get: operations["getCaseLog"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description The ID of the simulation. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
        /**
         * @description The ID of the case. 
         * @example case_1
         */
      path: {
        workspace: string;
        experimentId: string;
        caseId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/cases/{caseId}/result": {
    /** Download the result file for a finished case */
    get: operations["getCaseResults"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description The ID of the experiment. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
        /**
         * @description The ID of the case. 
         * @example case_1
         */
      path: {
        workspace: string;
        experimentId: string;
        caseId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/cases/{caseId}/trajectories": {
    /**
     * Get the trajectories for specified variables from the experiment result for a finished case 
     * @description This end-point can be used to fetch trajectories from cases that have finished executing. The trajectories are then typically used to visualize the result by plotting variables as a function of time or as X-Y plots. Which variables exists in a result can be obtained from the end-point GET /workspaces/{workspace}/experiments/{experimentId}/variables. Most experiments contain the independent variable 'time', with the custom function 'dynamic' being a notable example of this. So, to plot 'x' against 'time' for an experiment with a single case and the custom function 'dynamic', call this end-point with the input {'variable_names': ['x', 'time']} and plot 'item' 1 against 'item' 2 from the response. See the response description for more details on the structure of the response. The old (version 1) trajectory format can still be used but will be removed in a future version.
     */
    post: operations["getCaseTrajectories"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description The ID of the experiment. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
        /**
         * @description The ID of the case. 
         * @example case_1
         */
      path: {
        workspace: string;
        experimentId: string;
        caseId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/cases/{caseId}/custom-artifacts/{artifactId}": {
    /** Get an artifact for a case as stored by the custom function used for running the case */
    get: operations["getCustomArtifact"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description The ID of the experiment. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
        /**
         * @description The ID of the case. 
         * @example case_1
         */
        /**
         * @description The ID of the artifact. 
         * @example report
         */
      path: {
        workspace: string;
        experimentId: string;
        caseId: string;
        artifactId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/variables": {
    /** Get all variables in the experiment result */
    get: operations["getVariables"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description The ID of the experiment. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
      path: {
        workspace: string;
        experimentId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/trajectories": {
    /**
     * Get the trajectories for specified variables from the experiment result 
     * @description This end-point can be used to fetch trajectories from experiments that has finished executing. The trajectories are then typically used to visualize the result by plotting variables as a function of time or as X-Y plots. Which variables exists in a result can be obtained from the end-point GET /workspaces/{workspace}/experiments/{experimentId}/variables. Most experiments contain the independent variable 'time', with the custom function 'dynamic' being a notable example of this. So, to plot 'x' against 'time' for an experiment with a single case and the custom function 'dynamic', call this end-point with the input {'variable_names': ['x', 'time']} and plot 'item' 1 against 'item' 2 under 'case_1' in the response. See the response description for more details on the structure of the response. The old (version 1) trajectory format can still be used but will be removed in a future version.
     */
    post: operations["getTrajectories"];
    parameters: {
        /**
         * @description Name of the workspace. 
         * @example workspace
         */
        /**
         * @description The ID of the experiment. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
      path: {
        workspace: string;
        experimentId: string;
      };
    };
  };
  "/workspace-exports": {
    /**
     * Prepares a workspace for download as a zip file 
     * @description The compressed workspace will be prepared. After a successful completion of a call to this endpoint, call GET /workspace-exports/{exportId} to check status.
     */
    post: operations["prepareExportWorkspaceAsync"];
  };
  "/workspace-exports/{exportId}": {
    /**
     * Returns status for preparing a workspace for download. Also returns data for download when ready 
     * @description The workspace needs to be setup for export by calling POST /workspace-exports, before calling this API endpoint.
     */
    get: operations["exportWorkspaceAsync"];
    /**
     * Deletes a workspace export, including the compressed zip 
     * @description This API end point can be be called after a compressed workspace has been downloaded.
     */
    delete: operations["deleteExportedWorkspaceAsync"];
    parameters: {
        /**
         * @description ID of the compressed workspace to check status on. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        exportId: string;
      };
    };
  };
  "/workspace-imports": {
    /**
     * Start import of an existing workspace 
     * @description Will initiate import of an existing workspace. After a successful completion of a call to this endpoint, call GET /workspace-imports/{importId} to check status.
     */
    post: operations["importWorkspace"];
  };
  "/workspace-imports/{importId}": {
    /**
     * Returns status for a workspace import. Also returns data for the imported resource when ready 
     * @description The workspace needs to be setup for import by calling POST /workspace-imports, before calling this API endpoint.
     */
    get: operations["importWorkspaceStatus"];
    /**
     * Deletes a workspace import 
     * @description This API end point can be be called after a workspace has been imported.
     */
    delete: operations["deleteWorkspaceImport"];
    parameters: {
        /**
         * @description ID of the workspace import to check status on. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        importId: string;
      };
    };
  };
  "/workspace-imports-matchings": {
    /**
     * Get all projects matchings for workspace import 
     * @description Get all projects matchings that would happen during a workspace import. As import will fail if there are multiple possible matchings of local projects for a project, this end-point is used to get these matchings which can be resolved to an unequivocal 'selection'. Selections are used as (optional) input to the end-point /workspace-imports, see it for more details on the format of a selection.
     */
    post: operations["importWorkspaceMatchings"];
  };
  "/workspace-conversions": {
    /**
     * Starts a workspace conversion 
     * @description Will start a conversion of a workspace. A backup can optionally be made as part this conversion. As conversions are non-reversible it is recommended to create and keep a backup over a transition period. After a successful completion of a call to this endpoint, call GET /workspace-conversions/{conversionId} to check status.
     */
    post: operations["prepareWorkspaceConversionAsync"];
  };
  "/workspace-conversions/{conversionId}": {
    /**
     * Returns status for workspace conversion 
     * @description The workspace needs to be setup for conversion by calling POST /workspace-conversions, before calling this API endpoint.
     */
    get: operations["workspaceConversionStatusAsync"];
    /**
     * Deletes a workspace conversion 
     * @description This API end point can be be called after a workspace conversion is finished. Will not delete any created backups or revert any changes from on-going conversion.
     */
    delete: operations["deletedWorkspaceConversionAsync"];
    parameters: {
        /**
         * @description ID of the workspace conversion to check status on. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        conversionId: string;
      };
    };
  };
  "/exports/{exportId}": {
    /**
     * Downloads a file that has been setup to be exported 
     * @description This route is used for downloading exported files. Other end-points will reference here with a download URI.
     */
    get: operations["exportFile"];
    parameters: {
        /**
         * @description ID of the compressed workspace to download. 
         * @example 79sd8-3n2a4-e3t24
         */
      path: {
        exportId: string;
      };
    };
  };
  "/uploads/results": {
    /** Imports an result file */
    post: operations["uploadMAT"];
  };
  "/uploads/results/{uploadId}": {
    /**
     * Get the current status of upload 
     * @description Get the current status of upload for a given uploadId.
     */
    get: operations["getUploadStatus"];
    parameters: {
        /**
         * @description Id for result storage. 
         * @example 2f036b9fab6f45c788cc466da327cc78workspace
         */
      path: {
        uploadId: string;
      };
    };
  };
  "/external-result/{uploadId}": {
    /**
     * Get the result file meta-data 
     * @description Gets the meta-data for a result file.
     */
    get: operations["getUploadedResultEntity"];
    /** Deletes the result with the specified ID */
    delete: operations["deleteUploadedResultEntity"];
    parameters: {
        /**
         * @description Id for result storage. 
         * @example 2f036b9fab6f45c788cc466da327cc78workspace
         */
      path: {
        uploadId: string;
      };
    };
  };
  "/users/me": {
    /**
     * Gets data on the currently logged in user 
     * @description Returns the ID of the current user, which is used to create API keys, and the external IDs connected to it.
     */
    get: operations["getCurrentUser"];
  };
  "/users/{userId}/keys": {
    /**
     * Gets information on the API keys belonging to a user 
     * @description Get information on the API keys belonging to the user by the given ID. The information includes the key ID and the creation time but not the secret key itself.
     */
    get: operations["getAPIkeys"];
    /**
     * Creates a new API key 
     * @description Creates a new API key belonging to the user with the given ID. The response contains a new API key which is the only time this key can be retrieved. They key must be safely stored by the recepient, as there is no way to retrieve it at a later point. A user may only have one API key at a time, so if it is lost or compromised, it must be deleted before a new one can be created. The API key can be used with the /login endpoint to log in. Each key has an ID to identify it when deleting it.
     */
    post: operations["postAPIkey"];
    parameters: {
        /**
         * @description ID of the user. 
         * @example 3ae546601b0d473db83bccee0ca27c7e
         */
      path: {
        userId: string;
      };
    };
  };
  "/users/{userId}/keys/{keyId}": {
    /**
     * Deletes an API key 
     * @description Deletes an API key with the given ID, belonging to a specified user.
     */
    delete: operations["deleteAPIKey"];
  };
  "/keys/validation": {
    /**
     * Validates an API key 
     * @description Validates an API key.
     */
    post: operations["validateAPIKey"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** @description A project entity. */
    LocalProjectProtocol: {
      /**
       * @description ID of the project. 
       * @example 79sd8-3n2a4-e3t24
       */
      id: string;
      /** @description The definition of a project. */
      definition: {
        /**
         * @description Case sensitive project name. Must start with a letter and only use letters, numbers, underscores and dashes. 
         * @example MyProject
         */
        name: string;
        /**
         * @description The semantic version of the project. 
         * @example 2.0.3-beta.3+build.5
         */
        version?: string;
        /**
         * @description The semantic schema version of the project definition. 
         * @default 1.0.0 
         * @example 1.0.0
         */
        format: string;
        /** @default [] */
        dependencies: ({
            /**
             * @description The name of the project dependency. 
             * @example Modelica
             */
            name: string;
            /**
             * @description Version specifier. 
             * @example 4.0.0
             */
            versionSpecifier?: string;
          })[];
        /** @default [] */
        content: ({
            /**
             * Format: path 
             * @description Relative path in the project. Can be file or folder. 
             * @example SomeLib.mo
             */
            relpath: string;
            /**
             * @description Type of content. 
             * @enum {unknown}
             */
            contentType: "MODELICA" | "VIEWS" | "FAVORITES" | "CUSTOM_FUNCTIONS" | "REFERENCE_RESULTS" | "GENERIC" | "EXPERIMENT_DEFINITIONS";
            /**
             * @description Modelica library name or other name for display. 
             * @example SomeLib
             */
            name?: string;
            /**
             * @description If content entry gets disabled by default when included into a new workspace. 
             * @default false 
             * @example true
             */
            defaultDisabled: boolean;
            /**
             * @description ID of the project content. 
             * @example 79sd8-3n2a4-e3t24
             */
            id: string;
          })[];
        /** @default [] */
        executionOptions: ({
            /**
             * @description Custom function the options are for. 
             * @example steady state
             */
            customFunction: string;
            /**
             * @description Key-value pairs of compilation options. 
             * @example {
             *   "generate_html_diagnostics": true,
             *   "halt_on_warning": true
             * }
             */
            compiler: {
              [key: string]: (number | number | string | boolean) | undefined;
            };
            /**
             * @description Key-value pairs of run-time options. 
             * @example {
             *   "use_Brent_in_1d": false
             * }
             */
            runtime: {
              [key: string]: (number | number | string | boolean) | undefined;
            };
            /**
             * @description Key-value pairs of simulation options. 
             * @example {
             *   "ncp": 2000
             * }
             */
            simulation: {
              [key: string]: (number | number | string | boolean) | undefined;
            };
            /**
             * @description Key-value pairs of solver options. 
             * @example {
             *   "rtol": 0.0001
             * }
             */
            solver: {
              [key: string]: (number | number | string | boolean) | undefined;
            };
          })[];
        /**
         * @description The icon for the project. 
         * @example .impact/icon.png
         */
        icon?: string;
      };
      /**
       * @description The type of the project. 
       * @enum {unknown}
       */
      projectType: "LOCAL" | "RELEASED" | "SYSTEM";
      /** @description URI to a version control repository where the project is hosted. */
      vcsUri?: {
        /**
         * @description Supported Version Control System services. 
         * @enum {unknown}
         */
        serviceKind: "GIT" | "SVN" | "NONE";
        /**
         * @description Service URL. 
         * @example https://github.com
         */
        serviceUrl: string;
        /** @description URL to the repository. */
        repoUrl: {
          /**
           * @description The URL of the repository without schema part. 
           * @example gitlab.com/group/project
           */
          url: string;
          /**
           * @description A refname in the repository. 
           * @example main
           */
          refname: string;
          /**
           * @description Commit hash in the repository. Can be an empty string. 
           * @example 3486a89
           */
          sha1: string;
        } | {
          /**
           * @description Root URL of the repository without schema part. 
           * @example svn.company.com/Project01
           */
          rootUrl: string;
          /**
           * @description The trunk, branch or tag part of the URL. 
           * @example branches/someBranch
           */
          branch: string;
          /**
           * @description Relative url after branch. 
           * @example rest/of/url
           */
          urlFromRoot: string;
          /**
           * @description SVN revision of the repository (number of HEAD). 
           * @example 1000
           */
          revision: string;
        };
        /**
         * @description Protocol of the URI. 
         * @example https
         */
        protocol: string;
        /**
         * @description Sub-directory of the repository. 
         * @example src
         */
        subdir: string;
      };
      /** @description Disk space (in bytes) taken by the project. */
      size?: number;
    };
    /** @description The definition of a workspace. */
    WorkspaceDefinitionProtocol: {
      /**
       * @description The name of the workspace. 
       * @default New Workspace 
       * @example My workspace
       */
      name: string;
      /**
       * @description A description for the workspace. 
       * @default  
       * @example Workspace with all my projects
       */
      description: string;
      /**
       * @description The ID of the default project for the workspace. 
       * @default  
       * @example 79sd8-3n2a4-e3t24
       */
      defaultProjectId: string;
      /** @default [] */
      projects: ({
          /** @description A reference to a local project used by the workspace. */
          reference: {
            /**
             * @description Identifier for the local project. 
             * @example ac2d-47ca-a5d5
             */
            id: string;
            /**
             * @description The name of the released project. 
             * @example Hydralics
             */
            name: string;
            /**
             * @description The semantic version of the released project. 
             * @example 2.0.3
             */
            version?: string;
          } | {
            /**
             * @description Identifier for the local project. 
             * @example ac2d-47ca-a5d5
             */
            id: string;
            /**
             * @description The version control URI for the project. 
             * @example git+https://gitlab.com/group/project@main#SubDir
             */
            vcsUri: string;
          } | {
            /**
             * @description Identifier for the local project. 
             * @example ac2d-47ca-a5d5
             */
            id: string;
          };
          /**
           * @description If the project is disable for the workspace. 
           * @default false 
           * @example true
           */
          disabled: boolean;
          /**
           * @description List of content IDs for content entries that are disabled in the project. 
           * @example [
           *   "79sd8-3n2a4-e3t24",
           *   "t24e3-a43n2-d879s"
           * ]
           */
          disabledContent?: (string)[];
        })[];
      /** @default [] */
      dependencies: ({
          /** @description A reference to a local project used by the workspace. */
          reference: {
            /**
             * @description Identifier for the local project. 
             * @example ac2d-47ca-a5d5
             */
            id: string;
            /**
             * @description The name of the released project. 
             * @example Hydralics
             */
            name: string;
            /**
             * @description The semantic version of the released project. 
             * @example 2.0.3
             */
            version?: string;
          } | {
            /**
             * @description Identifier for the local project. 
             * @example ac2d-47ca-a5d5
             */
            id: string;
            /**
             * @description The version control URI for the project. 
             * @example git+https://gitlab.com/group/project@main#SubDir
             */
            vcsUri: string;
          } | {
            /**
             * @description Identifier for the local project. 
             * @example ac2d-47ca-a5d5
             */
            id: string;
          };
          /**
           * @description If the project is disable for the workspace. 
           * @default false 
           * @example true
           */
          disabled: boolean;
          /**
           * @description List of content IDs for content entries that are disabled in the project. 
           * @example [
           *   "79sd8-3n2a4-e3t24",
           *   "t24e3-a43n2-d879s"
           * ]
           */
          disabledContent?: (string)[];
        })[];
      /**
       * @description The semantic schema version of the workspace definition. 
       * @default 1.0.0 
       * @example 1.0.0
       */
      format: string;
      /**
       * @description Global unique ID for workspace. Used to access global Impact resources assocciated with workspace. 
       * @example 6d8ae8b3b0594125a0cb7acd6adbb0f9
       */
      guid: string;
      /**
       * @description The ID of the user that has created this workspace. 
       * @example 98dy-a82a-s8tg
       */
      createdBy: string;
      /**
       * @description The unix time at which the workspace was created. 
       * @example 1549552749
       */
      createdAt: number;
      /** @description If field exists, workspace is shared in App Mode. App Mode results in read only view of a single model in workspace. */
      appMode?: {
        /** @description The model to view in the App Mode workspace. */
        model: string;
      };
    };
    ProjectContentCreationModel: {
      /**
       * Format: path 
       * @description Relative path in the project. Can be file or folder. 
       * @example SomeLib.mo
       */
      relpath: string;
      /**
       * @description Type of content. 
       * @enum {unknown}
       */
      contentType: "MODELICA" | "VIEWS" | "FAVORITES" | "CUSTOM_FUNCTIONS" | "REFERENCE_RESULTS" | "GENERIC" | "EXPERIMENT_DEFINITIONS";
      /**
       * @description Modelica library name or other name for display. 
       * @example SomeLib
       */
      name?: string;
      /**
       * @description If content entry gets disabled by default when included into a new workspace. 
       * @default false 
       * @example true
       */
      defaultDisabled: boolean;
    };
    /** @description A content entry of a project. */
    ProjectContentModel: {
      /**
       * Format: path 
       * @description Relative path in the project. Can be file or folder. 
       * @example SomeLib.mo
       */
      relpath: string;
      /**
       * @description Type of content. 
       * @enum {unknown}
       */
      contentType: "MODELICA" | "VIEWS" | "FAVORITES" | "CUSTOM_FUNCTIONS" | "REFERENCE_RESULTS" | "GENERIC" | "EXPERIMENT_DEFINITIONS";
      /**
       * @description Modelica library name or other name for display. 
       * @example SomeLib
       */
      name?: string;
      /**
       * @description If content entry gets disabled by default when included into a new workspace. 
       * @default false 
       * @example true
       */
      defaultDisabled: boolean;
      /**
       * @description ID of the project content. 
       * @example 79sd8-3n2a4-e3t24
       */
      id: string;
    };
    /**
     * @description Existing local projects matching a project entry in workspace definition
     * during import.
     */
    VcsMatchingProtocol: {
      /**
       * @description ID of project entry in workspace definition. 
       * @example 79sd8-3n2a4-e3t24
       */
      entryId: string;
      /** @description The URI in the project entry the matching is done against. */
      uri: {
        /**
         * @description Supported Version Control System services. 
         * @enum {unknown}
         */
        serviceKind: "GIT" | "SVN" | "NONE";
        /**
         * @description Service URL. 
         * @example https://github.com
         */
        serviceUrl: string;
        /** @description URL to the repository. */
        repoUrl: {
          /**
           * @description The URL of the repository without schema part. 
           * @example gitlab.com/group/project
           */
          url: string;
          /**
           * @description A refname in the repository. 
           * @example main
           */
          refname: string;
          /**
           * @description Commit hash in the repository. Can be an empty string. 
           * @example 3486a89
           */
          sha1: string;
        } | {
          /**
           * @description Root URL of the repository without schema part. 
           * @example svn.company.com/Project01
           */
          rootUrl: string;
          /**
           * @description The trunk, branch or tag part of the URL. 
           * @example branches/someBranch
           */
          branch: string;
          /**
           * @description Relative url after branch. 
           * @example rest/of/url
           */
          urlFromRoot: string;
          /**
           * @description SVN revision of the repository (number of HEAD). 
           * @example 1000
           */
          revision: string;
        };
        /**
         * @description Protocol of the URI. 
         * @example https
         */
        protocol: string;
        /**
         * @description Sub-directory of the repository. 
         * @example src
         */
        subdir: string;
      };
      /** @description Local projects matching the project entry. */
      projects: ({
          /**
           * @description ID of the project. 
           * @example 79sd8-3n2a4-e3t24
           */
          id: string;
          /** @description The definition of a project. */
          definition: {
            /**
             * @description Case sensitive project name. Must start with a letter and only use letters, numbers, underscores and dashes. 
             * @example MyProject
             */
            name: string;
            /**
             * @description The semantic version of the project. 
             * @example 2.0.3-beta.3+build.5
             */
            version?: string;
            /**
             * @description The semantic schema version of the project definition. 
             * @default 1.0.0 
             * @example 1.0.0
             */
            format: string;
            /** @default [] */
            dependencies: ({
                /**
                 * @description The name of the project dependency. 
                 * @example Modelica
                 */
                name: string;
                /**
                 * @description Version specifier. 
                 * @example 4.0.0
                 */
                versionSpecifier?: string;
              })[];
            /** @default [] */
            content: ({
                /**
                 * Format: path 
                 * @description Relative path in the project. Can be file or folder. 
                 * @example SomeLib.mo
                 */
                relpath: string;
                /**
                 * @description Type of content. 
                 * @enum {unknown}
                 */
                contentType: "MODELICA" | "VIEWS" | "FAVORITES" | "CUSTOM_FUNCTIONS" | "REFERENCE_RESULTS" | "GENERIC" | "EXPERIMENT_DEFINITIONS";
                /**
                 * @description Modelica library name or other name for display. 
                 * @example SomeLib
                 */
                name?: string;
                /**
                 * @description If content entry gets disabled by default when included into a new workspace. 
                 * @default false 
                 * @example true
                 */
                defaultDisabled: boolean;
                /**
                 * @description ID of the project content. 
                 * @example 79sd8-3n2a4-e3t24
                 */
                id: string;
              })[];
            /** @default [] */
            executionOptions: ({
                /**
                 * @description Custom function the options are for. 
                 * @example steady state
                 */
                customFunction: string;
                /**
                 * @description Key-value pairs of compilation options. 
                 * @example {
                 *   "generate_html_diagnostics": true,
                 *   "halt_on_warning": true
                 * }
                 */
                compiler: {
                  [key: string]: (number | number | string | boolean) | undefined;
                };
                /**
                 * @description Key-value pairs of run-time options. 
                 * @example {
                 *   "use_Brent_in_1d": false
                 * }
                 */
                runtime: {
                  [key: string]: (number | number | string | boolean) | undefined;
                };
                /**
                 * @description Key-value pairs of simulation options. 
                 * @example {
                 *   "ncp": 2000
                 * }
                 */
                simulation: {
                  [key: string]: (number | number | string | boolean) | undefined;
                };
                /**
                 * @description Key-value pairs of solver options. 
                 * @example {
                 *   "rtol": 0.0001
                 * }
                 */
                solver: {
                  [key: string]: (number | number | string | boolean) | undefined;
                };
              })[];
            /**
             * @description The icon for the project. 
             * @example .impact/icon.png
             */
            icon?: string;
          };
          /**
           * @description The type of the project. 
           * @enum {unknown}
           */
          projectType: "LOCAL" | "RELEASED" | "SYSTEM";
          /** @description URI to a version control repository where the project is hosted. */
          vcsUri?: {
            /**
             * @description Supported Version Control System services. 
             * @enum {unknown}
             */
            serviceKind: "GIT" | "SVN" | "NONE";
            /**
             * @description Service URL. 
             * @example https://github.com
             */
            serviceUrl: string;
            /** @description URL to the repository. */
            repoUrl: {
              /**
               * @description The URL of the repository without schema part. 
               * @example gitlab.com/group/project
               */
              url: string;
              /**
               * @description A refname in the repository. 
               * @example main
               */
              refname: string;
              /**
               * @description Commit hash in the repository. Can be an empty string. 
               * @example 3486a89
               */
              sha1: string;
            } | {
              /**
               * @description Root URL of the repository without schema part. 
               * @example svn.company.com/Project01
               */
              rootUrl: string;
              /**
               * @description The trunk, branch or tag part of the URL. 
               * @example branches/someBranch
               */
              branch: string;
              /**
               * @description Relative url after branch. 
               * @example rest/of/url
               */
              urlFromRoot: string;
              /**
               * @description SVN revision of the repository (number of HEAD). 
               * @example 1000
               */
              revision: string;
            };
            /**
             * @description Protocol of the URI. 
             * @example https
             */
            protocol: string;
            /**
             * @description Sub-directory of the repository. 
             * @example src
             */
            subdir: string;
          };
          /** @description Disk space (in bytes) taken by the project. */
          size?: number;
        })[];
    };
    /** @description All selections to use during import of a workspace. */
    SelectedMatchingsProtocol: {
      entries: ({
          /**
           * @description ID of project entry the selection is for. 
           * @example 79sd8-3n2a4-e3t24
           */
          id: string;
          /** @description Selected local project. */
          project: {
            /**
             * @description ID of project. 
             * @example 79sd8-3n2a4-e3t24
             */
            id: string;
          };
        })[];
    };
    /** @description The definition of a workspace. */
    WorkspaceDefinitionCreationProtocol: {
      /**
       * @description The name of the workspace. 
       * @default New Workspace 
       * @example My workspace
       */
      name: string;
      /**
       * @description A description for the workspace. 
       * @default  
       * @example Workspace with all my projects
       */
      description: string;
      /**
       * @description The ID of the default project for the workspace. 
       * @default  
       * @example 79sd8-3n2a4-e3t24
       */
      defaultProjectId: string;
      /** @default [] */
      projects: ({
          /** @description A reference to a local project used by the workspace. */
          reference: {
            /**
             * @description Identifier for the local project. 
             * @example ac2d-47ca-a5d5
             */
            id: string;
            /**
             * @description The name of the released project. 
             * @example Hydralics
             */
            name: string;
            /**
             * @description The semantic version of the released project. 
             * @example 2.0.3
             */
            version?: string;
          } | {
            /**
             * @description Identifier for the local project. 
             * @example ac2d-47ca-a5d5
             */
            id: string;
            /**
             * @description The version control URI for the project. 
             * @example git+https://gitlab.com/group/project@main#SubDir
             */
            vcsUri: string;
          } | {
            /**
             * @description Identifier for the local project. 
             * @example ac2d-47ca-a5d5
             */
            id: string;
          };
          /**
           * @description If the project is disable for the workspace. 
           * @default false 
           * @example true
           */
          disabled: boolean;
          /**
           * @description List of content IDs for content entries that are disabled in the project. 
           * @example [
           *   "79sd8-3n2a4-e3t24",
           *   "t24e3-a43n2-d879s"
           * ]
           */
          disabledContent?: (string)[];
        })[];
      /** @default [] */
      dependencies: ({
          /** @description A reference to a local project used by the workspace. */
          reference: {
            /**
             * @description Identifier for the local project. 
             * @example ac2d-47ca-a5d5
             */
            id: string;
            /**
             * @description The name of the released project. 
             * @example Hydralics
             */
            name: string;
            /**
             * @description The semantic version of the released project. 
             * @example 2.0.3
             */
            version?: string;
          } | {
            /**
             * @description Identifier for the local project. 
             * @example ac2d-47ca-a5d5
             */
            id: string;
            /**
             * @description The version control URI for the project. 
             * @example git+https://gitlab.com/group/project@main#SubDir
             */
            vcsUri: string;
          } | {
            /**
             * @description Identifier for the local project. 
             * @example ac2d-47ca-a5d5
             */
            id: string;
          };
          /**
           * @description If the project is disable for the workspace. 
           * @default false 
           * @example true
           */
          disabled: boolean;
          /**
           * @description List of content IDs for content entries that are disabled in the project. 
           * @example [
           *   "79sd8-3n2a4-e3t24",
           *   "t24e3-a43n2-d879s"
           * ]
           */
          disabledContent?: (string)[];
        })[];
    };
    Error: {
      error?: {
        /**
         * @description Error message describing what went wrong. 
         * @example There was an error X because of Y
         */
        message?: string;
        /**
         * @description Error code for identifying specific errors. 
         * @example 12012
         */
        code?: number;
      };
    };
    /** @description Workspace meta-data. */
    Workspace: {
      /**
       * @description Unique workspace identifier. 
       * @example my_workspace
       */
      id: string;
      /** @description True, if the workspace is a clone. */
      is_clone: boolean;
      conversion?: {
        /**
         * @description IS_REQUIRED, if the workspace is of an old version and needs to be converted, else UP_TO_DATE. 
         * @enum {string}
         */
        state: "UP_TO_DATE" | "IS_REQUIRED";
      };
      definition: components["schemas"]["WorkspaceDefinitionProtocol"];
      /** @description If field exists, workspace is a backup created from another workspace. */
      backup?: {
        /**
         * @description The name of backup. 
         * @example My Workspace backup
         */
        name: string;
        /**
         * @description The ID of another workspace this workspace is a backup of. 
         * @example my_workspace
         */
        workspaceId: string;
      };
    };
    WorkspaceExportCreationProtocol: {
      /**
       * @description The ID of the workspace to export. 
       * @example my_workspace
       */
      workspaceId: string;
      /**
       * @description The contents to include in the workspace to be exported. If not specified, all the projects, dependencies, FMU's and experiments associated with the workspaced will be packaged for export. 
       * @default {
       *   "projects": {
       *     "includes": null
       *   },
       *   "dependencies": {
       *     "includes": null
       *   },
       *   "experiments": {
       *     "includes": null
       *   },
       *   "fmus": {
       *     "includes": null
       *   }
       * }
       */
      contents: {
        /**
         * @description Projects to include when exporting the workspace. If not specified or 'includes' set to None, all the workspace projects are added to export. To include specific projects, a list of project ID's can be specified as 'includes'. To exclude all projects, an empty list can be specified as 'includes'. 
         * @default {
         *   "includes": null
         * }
         */
        projects: {
          includes?: ({
              /**
               * @description ID of a project to include. 
               * @example b97e912af9804d26
               */
              id: string;
            })[];
        };
        /**
         * @description Projects dependencies to include when exporting the workspace. If not specified or 'includes' set to None, all the workspace dependencies are added to export. To include specific dependencies, a list of dependency ID's can be specified as 'includes'. To exclude all dependencies, an empty list can be specified as 'includes'. 
         * @default {
         *   "includes": null
         * }
         */
        dependencies: {
          includes?: ({
              /**
               * @description ID of a project dependency to include. 
               * @example c863600ce46f4474
               */
              id: string;
            })[];
        };
        /**
         * @description Experiments to include when exporting the workspace. If not specified or 'includes' set to None, all the experiment's associated with the workspace are added to export. To include specific experiments, a list of experiment ID's can be specified as 'includes'. To exclude all experiments, an empty list can be specified as 'includes'. 
         * @default {
         *   "includes": null
         * }
         */
        experiments: {
          includes?: ({
              /**
               * @description ID of an experiment to include. 
               * @example 12b5cf9b94b14aee
               */
              id: string;
            })[];
        };
        /**
         * @description FMU's to include when exporting the workspace. If not specified or 'includes' set to None, all the FMU's associated with the workspace are added to export. To include specific FMU's, a list of FMU ID's can be specified as 'includes'. To exclude all FMU's, an empty list can be specified as 'includes'. 
         * @default {
         *   "includes": null
         * }
         */
        fmus: {
          includes?: ({
              /**
               * @description ID of an FMU to include. 
               * @example 4cb6cedc73a040d1
               */
              id: string;
            })[];
        };
      };
      /** @description If field exists, workspace is exported as a read only app mode workspace. App Mode results in read only view of single model in workspace. If workspace is exported in app mode and no filters are specified in 'contents' for FMU or experiments, the latest FMU and experiment available for the model specified in app mode are packaged for export. */
      appMode?: {
        /** @description The model to view in the App Mode workspace. */
        model: string;
      };
    };
    Case: {
      /**
       * @description Case ID. 
       * @example case_1
       */
      id?: string;
      run_info: {
        /**
         * @description Status of the case run, can be 'successful', 'failed', 'not_started' or 'cancelled'. 
         * @example successful
         */
        status?: string;
        /**
         * @description At which stage the case failed if 'status' is 'failed', can be 'simulation' or 'compilation'. If 'status' is not 'failed' it will be null. 
         * @example simulation
         */
        failed_at?: string;
        /**
         * @description The unix time the case started running. 
         * @example 1549552749
         */
        datetime_started?: number;
        /**
         * @description The unix time the case finshed running. 
         * @example 1549552338
         */
        datetime_finished?: number;
        /**
         * @description Describes if the case 'input' is consistent with the latest case run. Will be false if the case has been updated and not executed since then. 
         * @example false
         */
        consistent?: boolean;
      };
      meta: {
        /**
         * @description Case label. 
         * @example Cruise operating point
         */
        label?: OneOf<[string, null]>;
      };
      input: {
        /**
         * @description Reference ID to the compiled model used running the case. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
        fmu_id?: string;
        /** @description The analysis object. */
        analysis: {
          /**
           * @description the name of the function to run. 
           * @example dynamic
           */
          analysis_function: string;
          /**
           * @description parameters to the function. 
           * @example {
           *   "start_time": 0,
           *   "final_time": 1
           * }
           */
          parameters?: Record<string, never>;
          /** @description Key-value pairs of simulation options. */
          simulation_options?: {
            [key: string]: (number | string | boolean) | undefined;
          };
          /** @description Key-value pairs of solver options. */
          solver_options?: {
            [key: string]: (number | string | boolean) | undefined;
          };
          /**
           * @description The simulation log level. 
           * @enum {string}
           */
          simulation_log_level?: "NOTHING" | "FATAL" | "ERROR" | "WARNING" | "INFO" | "VERBOSE" | "DEBUG" | "ALL";
        };
        /** @description Parameterization of the case, a list of key value pairs where key is variable name and value is the value to use  for that variable. */
        parametrization?: Record<string, never>;
        /** @description Structural parameterization of the case, a list of key value pairs where key is variable name and value is the value to use for that variable. These are values that cannot be applied to the FMU/Model after compilation. */
        structural_parametrization?: Record<string, never>;
        /** @description This is some base parametrization that must be applied to the FMU for it to be valid running this case. It often comes as a result from of caching to reuse the FMU. */
        fmu_base_parametrization?: Record<string, never>;
        /** @description Initialize the simulation using values from a previous simulation by giving the corresponding experiment ID and case ID. Details on how the initialization is done depend on the custom function. */
        initialize_from_case?: OneOf<[{
          /** @description Experiment ID to initialize from. */
          experimentId: string;
          /** @description Case ID to initialize from. */
          caseId: string;
        }, null]>;
        /** @description Initialize the simulation using an uploaded result file. Details on how the initialization is done depends upon the custom function. */
        initialize_from_external_result?: OneOf<[{
          /**
           * @description The ID of the result import. 
           * @example 2f036b9fab6f45c788cc466da327cc78workspace
           */
          uploadId: string;
        }, null]>;
      };
    };
    CaseExecutionOptions: {
      options: {
        /**
         * @description Key-value pairs of compilation options. 
         * @example {
         *   "generate_html_diagnostics": true,
         *   "halt_on_warning": true
         * }
         */
        compiler?: {
          [key: string]: (number | string | boolean) | undefined;
        };
        /**
         * @description Key-value pairs of run-time options. 
         * @example {
         *   "use_Brent_in_1d": false
         * }
         */
        runtime?: {
          [key: string]: (number | string | boolean) | undefined;
        };
        /**
         * @description Key-value pairs of simulation options. 
         * @example {
         *   "ncp": 2000
         * }
         */
        simulation?: {
          [key: string]: (number | string | boolean) | undefined;
        };
        /**
         * @description Key-value pairs of solver options. 
         * @example {
         *   "rtol": 0.0001
         * }
         */
        solver?: {
          [key: string]: (number | string | boolean) | undefined;
        };
      };
    };
    /**
     * @description Specifies expansion algorithm and its parameters. 
     * @example {
     *   "algorithm": "LatinHyperCube",
     *   "parameters": {
     *     "samples": 5,
     *     "seed": 1
     *   }
     * }
     */
    Expansion: components["schemas"]["LatinHyperCube"] | components["schemas"]["Sobol"] | components["schemas"]["FullFactorial"] | components["schemas"]["Saltelli"];
    FullFactorial: {
      /**
       * @description Full factorial expansion algorithm. 
       * @enum {string}
       */
      algorithm?: "FULLFACTORIAL";
    };
    LatinHyperCube: {
      /**
       * @description Latin hypercube sampling expansion algorithm. 
       * @enum {string}
       */
      algorithm: "LATINHYPERCUBE";
      /** @description Latin hypercube expansion algorithm parameters. */
      parameters: {
        /** @description The number of samples. Must be an integer greater than 1. */
        samples: number;
        /** @description The seed for random number generation. Default: None. */
        seed?: number;
      };
    };
    Sobol: {
      /**
       * @description Latin hypercube sampling expansion algorithm. 
       * @enum {string}
       */
      algorithm: "SOBOL";
      /** @description Latin hypercube expansion algorithm parameters. */
      parameters: {
        /** @description The number of samples. Must be an integer greater than 1. */
        samples: number;
      };
    };
    Saltelli: {
      /**
       * @description Saltelli expansion algorithm. 
       * @enum {string}
       */
      algorithm: "SALTELLI";
      /** @description Latin hypercube expansion algorithm parameters. */
      parameters: {
        /** @description The number of samples per (non-singular) modifier in the following sensitivity analysis. Must be a positive integer. It corresponds to the accuracy/resolution of the following sensisivity analysis and depends on the number of non-singular modifiers D. The number of cases in the resulting experiment expansion will be - N*(2*D + 2) if secondOrderAnalysis == true and N*(D + 2) if secondOrderAnalysis == false, where N is samplesPerModifier and D is the number of non-singular modifiers. */
        samplesPerModifier: number;
        /** @description Set to true if the resulting samples are to be used for second order sensitivity analysis, otherwise set to false. */
        secondOrderAnalysis: boolean;
      };
    };
    /** @description A compilation error with file and class location info. */
    ErrorWithFileAndClassLocation: {
      /**
       * @description The compilation error. 
       * @example The binding expression of the variable x does not match the declared type of the variable
       */
      msg?: string;
      /** @enum {string} */
      locationType?: "FileAndClassLocation";
      location?: {
        class?: {
          /** @example 2 */
          beginColumn?: number;
          /** @example 2 */
          endColumn?: number;
          /** @example 2 */
          beginLine?: number;
          /** @example 2 */
          endLine?: number;
          /**
           * @description Class name. 
           * @example Workspace.Example
           */
          qualifiedName?: string;
        };
        file?: components["schemas"]["FileLocation"];
      };
    };
    /** @description A compilation error with file location info. */
    ErrorWithFileLocation: {
      /**
       * @description The compilation error. 
       * @example Compilation error
       */
      msg?: string;
      /** @enum {string} */
      locationType?: "FileLocation";
      location?: components["schemas"]["FileLocation"];
    };
    /** @description A compilation error without location info. */
    ErrorWithNoLocation: {
      /**
       * @description The compilation error. 
       * @example Compilation error
       */
      msg?: string;
      /** @enum {string} */
      locationType?: "NoLocation";
    };
    /** @description A compilation error with path location info. */
    ErrorWithPathLocation: {
      /**
       * @description The compilation error. 
       * @example Compilation error
       */
      msg?: string;
      /** @enum {string} */
      locationType?: "PathLocation";
      location?: {
        /**
         * @description Path to a file used in compilation. 
         * @example /impact/libraries/BrokenLib/BrokenFile.moc
         */
        path?: string;
      };
    };
    ModelExecutableItemV2: {
      /** @example workspace_pid_controller_20090615_134530_as86g32 */
      id?: string;
      /** @description The input for how the compilation was done. */
      input?: {
        /**
         * @description Model class name. 
         * @example Workspace.PID_Controller
         */
        class_name?: string;
        /**
         * @description Compiler options settings. 
         * @example {
         *   "generate_html_diagnostics": true
         * }
         */
        compiler_options?: Record<string, never>;
        /**
         * @description Runtime options settings. 
         * @example {
         *   "log_level": 4
         * }
         */
        runtime_options?: Record<string, never>;
        /**
         * @description Compiler log level. 
         * @example info
         */
        compiler_log_level?: string;
        /**
         * @description Flavour of the FMU. 
         * @example me
         */
        fmi_target?: string;
        /**
         * @description Version of FMI for the FMU. 
         * @example 2.0
         */
        fmi_version?: string;
        /**
         * @description Platform for FMU binary. 
         * @example win64
         */
        platform?: string;
        /**
         * @description An unique identifier representing some state of all models and libraries used when compiling. 
         * @example 2b3a4-adf3
         */
        model_snapshot?: string;
        /**
         * @description List of libraries not used when compiling. 
         * @example [VDL, ML]
         */
        disabled_libs?: (string)[];
        /**
         * @description Representing an aggregated version of all tooling used when compiling, will now always be 0.0.1. 
         * @example 0.0.1
         */
        toolchain_version?: string;
      };
      /** @description The run info of the compilation. */
      run_info?: {
        /**
         * @description String that is 'cancelled', 'failed' or 'successful' depending on if the compilation finished successfully. 
         * @example failed
         */
        status?: string;
        /**
         * @description The unix time the compilation was started. 
         * @example 1549552749
         */
        datetime_started?: number;
        /** @description An array containing the compilation errors in case status is 'failed'. */
        errors?: (components["schemas"]["ErrorWithFileAndClassLocation"] | components["schemas"]["ErrorWithFileLocation"] | components["schemas"]["ErrorWithNoLocation"] | components["schemas"]["ErrorWithPathLocation"])[];
        /**
         * @description The unix time the compilation was finished. 
         * @example 1549552338
         */
        datetime_finished?: number;
      };
    };
    ModelExecutableListV2: {
      data?: {
        /** @description List of all model executables. */
        items?: (components["schemas"]["ModelExecutableItemV2"])[];
      };
    };
    ModelExecutableItemV1: {
      /** @example workspace_pid_controller_20090615_134530_as86g32 */
      id?: string;
      /** @description The input for how the compilation was done. */
      input?: {
        /**
         * @description Model class name. 
         * @example Workspace.PID_Controller
         */
        class_name?: string;
        /**
         * @description Compiler options settings. 
         * @example {
         *   "generate_html_diagnostics": true
         * }
         */
        compiler_options?: Record<string, never>;
        /**
         * @description Runtime options settings. 
         * @example {
         *   "log_level": 4
         * }
         */
        runtime_options?: Record<string, never>;
        /**
         * @description Compiler log level. 
         * @example info
         */
        compiler_log_level?: string;
        /**
         * @description Flavour of the FMU. 
         * @example me
         */
        fmi_target?: string;
        /**
         * @description Version of FMI for the FMU. 
         * @example 2.0
         */
        fmi_version?: string;
        /**
         * @description Platform for FMU binary. 
         * @example win64
         */
        platform?: string;
        /**
         * @description An unique identifier representing some state of all models and libraries used when compiling. 
         * @example 2b3a4-adf3
         */
        model_snapshot?: string;
        /**
         * @description List of libraries not used when compiling. 
         * @example [VDL, ML]
         */
        disabled_libs?: (string)[];
        /**
         * @description Representing an aggregated version of all tooling used when compiling, will now always be 0.0.1. 
         * @example 0.0.1
         */
        toolchain_version?: string;
      };
      /** @description The run info of the compilation. */
      run_info?: {
        /**
         * @description String that is 'cancelled', 'failed' or 'successful' depending on if the compilation finished successfully. 
         * @example failed
         */
        status?: string;
        /**
         * @description The unix time the compilation was started. 
         * @example 1549552749
         */
        datetime_started?: number;
        /**
         * @description An array containing the compilation errors in case status is 'failed'. 
         * @example [
         *   "Could not match 'variable1' with any equation",
         *   "Nominal of 'variable2' is 0"
         * ]
         */
        errors?: (string)[];
        /**
         * @description The unix time the compilation was finished. 
         * @example 1549552338
         */
        datetime_finished?: number;
      };
    };
    ModelExecutableListV1: {
      data?: {
        /** @description List of all model executables. */
        items?: (components["schemas"]["ModelExecutableItemV1"])[];
      };
    };
    ExperimentItemV2: {
      /** @example workspace_pid_controller_20200705_170234_546ccba */
      id?: string;
      experiment?: components["schemas"]["ExperimentDefinition"];
      run_info?: {
        /**
         * @description String that is 'cancelled', 'failed' or 'done' depending on if all parts of the experiment could run. 
         * @example failed
         */
        status?: string;
        /**
         * @description An array containing errors if status is 'failed'. 
         * @example [
         *   "Current settings will generate a large amount of simulation cases. Try reducing the number of simulation cases."
         * ]
         */
        errors?: (string)[];
        /**
         * @description Number of cases that are failed. 
         * @example 0
         */
        failed?: number;
        /**
         * @description Number of cases that are successful. 
         * @example 15
         */
        successful?: number;
        /**
         * @description Number of cases that are not started. 
         * @example 0
         */
        not_started?: number;
        /**
         * @description Number of cases that are cancelled. 
         * @example 0
         */
        cancelled?: number;
      };
      meta_data?: components["schemas"]["ExperimentMetaData"];
    };
    ExperimentListV2: {
      data?: {
        /** @description List of all experiments. */
        items?: (components["schemas"]["ExperimentItemV2"])[];
      };
    };
    ExperimentItemV1: {
      /** @example workspace_pid_controller_20200705_170234_546ccba */
      id?: string;
      experiment?: {
        /**
         * @description Reference ID to the compiled model. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
        fmu_id: string;
        /**
         * @example {
         *   "variables": {
         *     "integrator.k": 1,
         *     "inertia1.J": "range(1,5,5)",
         *     "inertia2.J": "range(5,10,3)"
         *   },
         *   "initializeFrom": ""
         * }
         */
        modifiers?: {
          /** @description Specifies parameter values and ranges. The range operator allows a range of values to be described: e.g. range(0,1,5) describes 5 evenly spaced values between 0 and 1: [0,0.25,0.5,0.75,1]. If multiple range operators are specified a full factorial is used to determine all different parameterizations for the experiment. */
          variables?: {
            [key: string]: (number | string | boolean) | undefined;
          };
          /** @description Initialize the simulation using values from a previous simulation by giving the corresponding experiment ID. The experiment used must be for a simulation with a single case, otherwise 'initializeFromCase' must be used. Details on how the initialization is done depend on the custom function. */
          initializeFrom?: string;
        };
        /** @description The analysis object. */
        analysis: {
          /**
           * @description The name of the custom function that will be executed. 
           * @example dynamic
           */
          analysis_function: string;
          /**
           * @description Parameters to the custom function. 
           * @example {
           *   "start_time": 0,
           *   "final_time": 1
           * }
           */
          parameters?: {
            [key: string]: (number | string | boolean) | undefined;
          };
          /** @description Key-value pairs of simulation options. */
          simulation_options?: {
            [key: string]: (number | string | boolean) | undefined;
          };
          /** @description Key-value pairs of solver options. */
          solver_options?: {
            [key: string]: (number | string | boolean) | undefined;
          };
          /**
           * @description The simulation log level. 
           * @default WARNING 
           * @enum {string}
           */
          simulation_log_level: "NOTHING" | "FATAL" | "ERROR" | "WARNING" | "INFO" | "VERBOSE" | "DEBUG" | "ALL";
        };
      };
      run_info?: {
        /**
         * @description String that is 'cancelled', 'failed' or 'done' depending on if all parts of the experiment could run. 
         * @example failed
         */
        status?: string;
        /**
         * @description An array containing errors if status is 'failed'. 
         * @example [
         *   "Current settings will generate a large amount of simulation cases. Try reducing the number of simulation cases."
         * ]
         */
        errors?: (string)[];
        /**
         * @description Number of cases that are failed. 
         * @example 0
         */
        failed?: number;
        /**
         * @description Number of cases that are successful. 
         * @example 15
         */
        successful?: number;
      };
      meta_data?: components["schemas"]["ExperimentMetaData"];
    };
    ExperimentListV1: {
      data?: {
        /** @description List of all experiments. */
        items?: (components["schemas"]["ExperimentItemV1"])[];
      };
    };
    FileLocation: {
      /** @example 2 */
      beginColumn?: number;
      /** @example 2 */
      endColumn?: number;
      /** @example 2 */
      beginLine?: number;
      /** @example 2 */
      endLine?: number;
      /**
       * @description Modelica code snippet from error location. Entire lines of location, no consideration to columns is done. 
       * @example   Real x = "asdf";
       */
      context?: string;
      /**
       * @description Filename. 
       * @example /impact/workspaces/example_workspace/model_libraries/editable/Workspace/Example.mo
       */
      file?: string;
    };
    /** @description The analysis object. */
    Analysis: {
      /**
       * @description The name of the custom function that will be executed. 
       * @example dynamic
       */
      type: string;
      /**
       * @description Parameters to the custom function. 
       * @example {
       *   "start_time": 0,
       *   "final_time": 1
       * }
       */
      parameters?: {
        [key: string]: (number | string | boolean) | undefined;
      };
      /** @description Key-value pairs of simulation options. */
      simulationOptions?: {
        [key: string]: (number | string | boolean) | undefined;
      };
      /** @description Key-value pairs of solver options. */
      solverOptions?: {
        [key: string]: (number | string | boolean) | undefined;
      };
      /**
       * @description The simulation log level. 
       * @default WARNING 
       * @enum {string}
       */
      simulationLogLevel: "NOTHING" | "FATAL" | "ERROR" | "WARNING" | "INFO" | "VERBOSE" | "DEBUG" | "ALL";
    };
    /**
     * @example {
     *   "variables": {
     *     "integrator.k": 1,
     *     "inertia1.J": "uniform(1,5)",
     *     "inertia2.J": 2
     *   },
     *   "initializeFrom": ""
     * }
     */
    Modifiers: {
      /** @description Specifies parameter values and ranges. The range operator allows a range of values to be described: e.g. range(0,1,5) describes 5 evenly spaced values between 0 and 1: [0,0.25,0.5,0.75,1]. If multiple range operators are specified, a full factorial expansion is used to determine all different parameterizations for the experiment. */
      variables?: {
        [key: string]: (number | string | boolean) | undefined;
      };
      /** @description Initialize the simulation using values from a previous simulation by giving the corresponding experiment ID. The experiment used must be for a simulation with a single case, otherwise 'initializeFromCase' must be used. Details on how the initialization is done depend on the custom function. */
      initializeFrom?: string;
      /** @description Same as 'initializeFrom' but also the case ID to initialize from must be specified. Can be reference a case from an experiment with multiple cases. */
      initializeFromCase?: {
        /** @description Experiment ID to initialize from. */
        experimentId: string;
        /** @description Case ID to initialize from. */
        caseId: string;
      };
      /**
       * @description The ID of the result import. 
       * @example 2f036b9fab6f45c788cc466da327cc78workspace
       */
      initializeFromExternalResult?: string;
    };
    /** @description List of extensions to define cases. Each 'extension' defined will be merged with 'base' to create a case. When merging 'base' with an 'extension', the 'extension' will override the corresponding definitions in 'base'. It is not possible to use any operators (like the range operator) when using extensions. */
    Extensions: ({
        /**
         * @example {
         *   "variables": {
         *     "inertia2.J": 5
         *   }
         * }
         */
        modifiers?: {
          /** @description Specifies parameter values. */
          variables?: {
            [key: string]: (number | string | boolean) | undefined;
          };
          /** @description Initialize the simulation using values from a previous simulation by giving the corresponding experiment ID. The experiment used must be for a simulation with a single case, otherwise 'initializeFromCase' must be used. Details on how the initialization is done depend on the custom function. */
          initializeFrom?: string;
          /** @description Same as 'initializeFrom' but also the case ID to initialize from must be specified. Can be reference a case from an experiment with multiple cases. */
          initializeFromCase?: {
            /** @description Experiment ID to initialize from. */
            experimentId: string;
            /** @description Case ID to initialize from. */
            caseId: string;
          };
        };
        /** @description An array of case data. Only the first index in the case data array will be used for extensions currently. */
        caseData?: ({
            /** @description Specifies case label. */
            label?: OneOf<[string, null]>;
          })[];
        /** @description The analysis object. */
        analysis?: {
          /**
           * @description Parameters to the custom function. 
           * @example {
           *   "start_time": 0,
           *   "final_time": 1
           * }
           */
          parameters?: {
            [key: string]: (number | string | boolean) | undefined;
          };
          /** @description Key-value pairs of simulation options. */
          simulationOptions?: {
            [key: string]: (number | string | boolean) | undefined;
          };
          /** @description Key-value pairs of solver options. */
          solverOptions?: {
            [key: string]: (number | string | boolean) | undefined;
          };
          /**
           * @description The simulation log level. 
           * @default WARNING 
           * @enum {string}
           */
          simulationLogLevel: "NOTHING" | "FATAL" | "ERROR" | "WARNING" | "INFO" | "VERBOSE" | "DEBUG" | "ALL";
        };
      })[];
    FmuModel: {
      fmu: {
        /**
         * @description Reference ID to the compiled model. 
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
        id: string;
      };
    };
    ModelicaModel: {
      modelica: {
        /**
         * @description Model class name. 
         * @example Modelica.Fluid.Examples.PumpingSystem
         */
        className: string;
        /**
         * @description Key-value pairs of compilation options. 
         * @default {
         *   "c_compiler": "gcc"
         * } 
         * @example {
         *   "generate_html_diagnostics": true
         * }
         */
        compilerOptions: {
          [key: string]: (number | string | boolean) | undefined;
        };
        /**
         * @description Key-value pairs of run-time options. 
         * @default {} 
         * @example {
         *   "log_level": 4
         * }
         */
        runtimeOptions: {
          [key: string]: (number | string | boolean) | undefined;
        };
        /**
         * @description Compiler log level. 
         * @default warning 
         * @example info
         */
        compilerLogLevel: string;
        /**
         * @description Flavour of the FMU. 
         * @default me 
         * @example me 
         * @enum {string}
         */
        fmiTarget: "me" | "cs" | "me+cs";
        /**
         * @description Version of FMI for the FMU. 
         * @default 2.0 
         * @example 2.0 
         * @enum {string}
         */
        fmiVersion: "1.0" | "2.0";
        /**
         * @description Platform for FMU binary. 
         * @default auto 
         * @example win64 
         * @enum {string}
         */
        platform: "linux64" | "win32" | "win64" | "auto";
      };
    };
    /** @description The model to use for the experiment. */
    Model: components["schemas"]["FmuModel"] | components["schemas"]["ModelicaModel"];
    ExperimentDefinition: {
      /**
       * @description Experiment version, should be '2'. 
       * @example 2
       */
      version: number;
      base: {
        model: components["schemas"]["Model"];
        modifiers?: components["schemas"]["Modifiers"];
        expansion?: components["schemas"]["Expansion"];
        analysis: components["schemas"]["Analysis"];
      };
      extensions?: components["schemas"]["Extensions"];
    };
    ExperimentMetaData: {
      /** @example workspace_pid_controller_20090615_134530_as86g32 */
      experiment_hash?: string;
      model_names?: (string)[];
      /** @example 1550836039 */
      created_epoch?: number;
      /** @example my label */
      label?: string;
      /**
       * @description Up to 2048 bytes of custom data to be associated with the experiment. 
       * @example {
       *   "parametrizationFrom": "specification 3.4",
       *   "externalToolVersion": "9.0"
       * }
       */
      user_data?: Record<string, never>;
    };
    ExternalResultUploadStatus: {
      data?: {
        /**
         * @description The ID of the result import. 
         * @example 2f036b9fab6f45c788cc466da327cc78workspace
         */
        id?: string;
        /**
         * @description current status of the upload. 
         * @example ready
         */
        status?: string;
        /** @description Data for access to the meta data for the given upload, only exists in response if the upload was successful. Use the field 'status' to see if this is the case. */
        data?: {
          /**
           * @description URI for the result resource. 
           * @example api/external-result/2f036b9fab6f45c788cc466da327cc78workspace
           */
          resourceUri?: string;
        };
        /** @description Error message if the upload fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
        error?: {
          /**
           * @description Error message describing what went wrong. 
           * @example Could not upload given result file to the specified workspace. Could not read version number of the workspace 'my_workspace' or unsupported file type given.
           */
          message?: string;
          /**
           * @description Error code for identifying specific errors. 
           * @example 12015
           */
          code?: number;
        };
      };
    };
    ConversionSpecProtocol: {
      /**
       * @description ID of workspace to convert. 
       * @example my_workspace
       */
      workspaceId: string;
      backup?: {
        /**
         * @description The name of the backup workspace to create. 
         * @example my_workspace_backup
         */
        name: string;
      };
      /**
       * @description List of issue IDs to ignore when converting the workspace. 
       * @example [
       *   "t24e3-sd879-2a43n"
       * ]
       */
      ignores?: (string)[];
    };
    ConversionsChecksProtocol: {
      /** @description List of all conversions that needs to be done for the workspace. */
      conversions: ({
          /**
           * @description The version the conversion is done from. 
           * @example 0.8
           */
          from: string;
          /**
           * @description The version the conversion is done to. 
           * @example 0.9
           */
          to: string;
          /** @description List of all isses found for conversion. */
          issues: ({
              /**
               * @description ID of the issue. Can be used to later ignore it. 
               * @example t24e3-sd879-2a43n
               */
              id: string;
              /**
               * @description A readable string on what the issue is. 
               * @example Symbolic link for library Hydralics 4.10 cannot be converted, you need to checkout svn.company.com/Project01 in the new structure
               */
              message: string;
              details: OneOf<[{
                /**
                 * @default GIT_CHECKOUT_MISSING 
                 * @enum {string}
                 */
                type: "GIT_CHECKOUT_MISSING";
                /**
                 * @description The URL of the repository. 
                 * @example gitlab.com/group/project
                 */
                url: string;
                /**
                 * @description The branch of the the repository. 
                 * @example main
                 */
                branch: string;
              }, {
                /**
                 * @default SVN_CHECKOUT_MISSING 
                 * @enum {string}
                 */
                type: "SVN_CHECKOUT_MISSING";
                /**
                 * @description The URL of the repository. 
                 * @example svn.company.com/Project01
                 */
                url: string;
              }]>;
            })[];
        })[];
      /** @description Backup information for the workspace. */
      backup: {
        /** @description Disk information for creating a backup. */
        disk: {
          /** @description Free disk space (in bytes) that exists on the system. */
          free: number;
          /** @description Required disk space (in bytes) for creating a backup. */
          required: number;
        };
      };
    };
  };
  responses: {
    /** @description The request could not be processed. The request is most likely not correct. */
    BadRequest: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description The request could not be performed because of missing authentication. */
    Unauthenticated: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description The request could not be performed because the system is out of payed for floating seats. */
    OutOfSeats: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Action is not allowed. Permissions might be insufficient. */
    LicenseError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description The resource could not be found. Typically this means that a resource the request is referencing does not exists. Common resources are workspaces, libraries, model-executables and experiments. */
    ResourceCouldNotBeFound: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description The request could not be performed because there is a conflict. */
    Conflict: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description An internal server error. */
    UnexpectedError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
  };
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  getAPIMetaData: {
    /**
     * Returns an object with meta data for this API 
     * @description Can be used by client to check that the API is of a version it supports. The APIs version is semantic.
     */
    responses: {
      /** @description A JSON object consisting of the APIs meta data, most notably the semantic version of it. */
      200: {
        content: {
          "application/json": {
            /** @description The semantic version of this API. */
            version?: string;
          };
        };
      };
      500: components["responses"]["UnexpectedError"];
    };
  };
  login: {
    /**
     * Logs in a user 
     * @description When the login succeeds, the response includes a cookie containing an access token which is used for further identification with the REST API. The login is managed by a third party authorization service. To authenticate against the REST API, an API key may be included in the optional request body. The API key can be created <a class="visible-link" href="/admin/keys">in the API key manager</a>.
     */
    parameters?: {
        /**
         * @description The OAuth grant type to use for the login, one of refresh_token or client_credentials (default). 
         * @example refresh_token
         */
      query?: {
        grant_type?: string;
      };
    };
    /** @description Optional request body for logging in with an API key. */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description An API key. 
           * @example secret-api-key
           */
          secretKey?: string;
        };
      };
    };
    responses: {
      /** @description The user is already logged in and the JWT is valid. */
      200: {
        content: {
          "application/json": {
            /** @description A user identifier. */
            identifier?: string;
          };
        };
      };
      /** @description The user was logged in and a new JWT was created. */
      201: {
        content: {
          "application/json": {
            /** @description A user identifier. */
            identifier?: string;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getProjects: {
    /**
     * Get all projects 
     * @description Returns a list of all local projects that exists. The query parameter vcsInfo can be used to also get info on how projects are version controlled.
     */
    responses: {
      /** @description OK: The projects were returned. */
      200: {
        content: {
          "application/json": {
            data?: {
              items?: (components["schemas"]["LocalProjectProtocol"])[];
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importProject: {
    /**
     * Start import of a project 
     * @description Will initiate import of a project. After a successful completion of a call to this endpoint, call GET /project-imports/{importId} to check status.
     */
    /** @description A zip file of a project given with multipart/form-data to import a project. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The zip-file. 
           * @example my_project.zip
           */
          file?: string;
        };
      };
    };
    responses: {
      /** @description Project import created and location to check status of import is returned. */
      201: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The location of the project import. 
               * @example api/project-imports/fd90-4gkl-vf89
               */
              location?: string;
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importProjectStatus: {
    /**
     * Returns status for a project import. Also returns data for the imported resource when ready 
     * @description The project needs to be setup for import by calling POST /project-imports, before calling this API endpoint.
     */
    responses: {
      /** @description Status for a project import and data to resource if import is done and project is ready to be used. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description ID for project import. 
               * @example 79sd8-3n2a4-e3t24
               */
              id?: string;
              /** @description Will be 'running' if import is on-going, 'ready' if import is finished and can be used, or 'error' if an error occured. */
              status?: string;
              /** @description Data for the project imported, only exists in response if project is imported and ready to use. Use the field 'status' to see if this is the case. */
              data?: {
                /**
                 * @description URI for the imported project resource. 
                 * @example api/projects/72d3969cca3fc912aca1097bcc49dda0a4481a06
                 */
                resourceUri?: string;
                /**
                 * @description The ID for the project imported. 
                 * @example 72d3969cca3fc912aca1097bcc49dda0a4481a06
                 */
                projectId?: string;
              };
              /** @description Error message if the import fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
              error?: {
                /**
                 * @description Error message describing what went wrong. 
                 * @example Could not import project 'my_project'. Could not read version number of the project 'my_project'. Either the project is corrupt or needs to be updated using an older version of Modelon Impact
                 */
                message?: string;
                /**
                 * @description Error code for identifying specific errors. 
                 * @example 12015
                 */
                code?: number;
              };
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteProjectImport: {
    /**
     * Deletes a project import 
     * @description This API end point can be be called after a project has been imported.
     */
    responses: {
      /** @description OK: The project import with the specified ID was deleted. */
      200: never;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  prepareExportProjectAsync: {
    /**
     * Prepares a project for download as a zip file 
     * @description The compressed project will be prepared. After a successful completion of a call to this endpoint, call GET /project-exports/{exportId} to check status.
     */
    /** @description Project to export. */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The ID for the project to export. 
           * @example my_project
           */
          projectId: string;
        };
      };
    };
    responses: {
      /** @description The location for checking status and possible data for compressed project. */
      201: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description location for checking status of project compression. 
               * @example api/project-exports/79sd8-3n2a4-e3t24
               */
              location?: string;
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  exportProjectAsync: {
    /**
     * Returns status for preparing a project for download. Also returns data for download when ready 
     * @description The project needs to be setup for export by calling POST /project-exports, before calling this API endpoint.
     */
    responses: {
      /** @description Status for a project export and data to download it if ready. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description ID for project export. 
               * @example 79sd8-3n2a4-e3t24
               */
              id?: string;
              /** @description Will be 'running' if export is on-going, 'ready' if export is finished and can be downloaded, or 'error' if an error occured. */
              status?: string;
              /** @description Data for the project to download, only exists in response if project is ready to be downloaded. Use the field 'status' to see if this is the case. */
              data?: {
                /**
                 * @description URI for downloading the project. 
                 * @example api/exports/79sd8-3n2a4-e3t24
                 */
                downloadUri?: string;
                /**
                 * @description The size of the compressed project, in bytes. 
                 * @example 10481015
                 */
                size?: number;
              };
              /** @description Error message if the export fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
              error?: {
                /**
                 * @description Error message describing what went wrong. 
                 * @example Could not export project 'my_project'. Maximum allowed zip file size of 95MB exceeded
                 */
                message?: string;
                /**
                 * @description Error code for identifying specific errors. 
                 * @example 12072
                 */
                code?: number;
              };
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteExportedProjectAsync: {
    /**
     * Deletes a project export, including the compressed zip 
     * @description This API end point can be be called after a compressed project has been downloaded.
     */
    responses: {
      /** @description OK: The project export with the specified ID was deleted. */
      200: never;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getProject: {
    /**
     * Get a project 
     * @description Returns a project given a project ID. The query parameter vcsInfo can be used to also get info on how the project is version controlled.
     */
    parameters?: {
        /**
         * @description If true, returned project vcsUri field will be set if the project is version controlled. If false, vscUri will not be set for the returned project. Default is false. 
         * @example vcsInfo=true
         */
        /**
         * @description If true, returned project size field will be set. If false, size will not be set for the returned project. Default is false. 
         * @example sizeInfo=true
         */
      query?: {
        vcsInfo?: string;
        sizeInfo?: string;
      };
    };
    responses: {
      /** @description OK: The project were returned. */
      200: {
        content: {
          "application/json": components["schemas"]["LocalProjectProtocol"];
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  updateProject: {
    /**
     * Update a project 
     * @description Updates a project given project data and a project ID. Only the project definition is allowed to be updated and content entries cannot be added or deleted. Content ID or project format cannot be updated.
     */
    /** @description The project data that should be used to update the entity server side. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["LocalProjectProtocol"];
      };
    };
    responses: {
      /** @description OK: The project were updated. */
      200: {
        content: {
          "application/json": components["schemas"]["LocalProjectProtocol"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteProject: {
    /**
     * Delete a project 
     * @description Deletes a project given a project ID. Will also delete any reference from workspaces to this project.
     */
    responses: {
      /** @description OK: The project were deleted. */
      200: {
        content: {
          "application/json": components["schemas"]["LocalProjectProtocol"];
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  createContent: {
    /**
     * Create new content entry 
     * @description Will create a new content entry for a project. For MODELICA content entries an empty structured modelica library will also be created on disk.
     */
    /** @description Specification for the new content entry. */
    requestBody: {
      content: {
        "application/json": {
          new: components["schemas"]["ProjectContentCreationModel"];
        };
      };
    };
    responses: {
      /** @description Content entry is created and returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ProjectContentModel"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getContent: {
    /**
     * Get a content entry 
     * @description Returns a content entry given project and content IDs.
     */
    responses: {
      /** @description OK: The content entry were returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ProjectContentModel"];
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteContent: {
    /**
     * Delete a content entry 
     * @description Deletes a content entry from a project. Any files on disk that exists for this content is also deleted.
     */
    responses: {
      /** @description OK: The content were deleted. */
      200: {
        content: {
          "application/json": components["schemas"]["ProjectContentModel"];
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importContent: {
    /**
     * Start import of existing content 
     * @description Will initiate import of existing content. After a successful completion of a call to this endpoint, call GET /projects/{project}/content-imports/{importId} to check status.
     */
    /** @description A zip file or a .mo file (For MODELICA content) given with multipart/form-data is used to import content. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The zip-file. 
           * @example modelica.zip
           */
          file?: string;
          /** @description Import options. */
          options?: {
            /**
             * @description Type of content. Only MODELICA is supported as of now. 
             * @enum {unknown}
             */
            contentType?: "MODELICA" | "VIEWS" | "FAVOURITES" | "CUSTOM_FUNCTIONS" | "REFERENCE_RESULTS" | "GENERIC";
          };
        };
      };
    };
    responses: {
      /** @description Content import created and location to check status of import is returned. */
      201: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The ID of the workspace import. 
               * @example api/projects/79sd8-3n2a4-e3t24/content-imports/fd90-4gkl-vf89
               */
              location?: string;
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importContentStatus: {
    /**
     * Returns status for a content import. Also returns data for the imported resource when ready 
     * @description The content needs to be setup for import by calling POST /content-imports, before calling this API endpoint.
     */
    responses: {
      /** @description Status for a content import and data to resource if import is done and content is ready to be used. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description ID for content import. 
               * @example 79sd8-3n2a4-e3t24
               */
              id?: string;
              /** @description Will be 'running' if import is on-going, 'ready' if import is finished and can be used, or 'error' if an error occured. */
              status?: string;
              /** @description Data for the content imported, only exists in response if content is imported and ready to use. Use the field 'status' to see if this is the case. */
              data?: {
                /**
                 * @description URI for the imported workspace resource. 
                 * @example api/projects/a9g0-adfd/contents/u760-u095-gu45
                 */
                resourceUri?: string;
                /**
                 * @description The ID for the content imported. 
                 * @example u760-u095-gu45
                 */
                contentId?: string;
              };
              /** @description Error message if the import fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
              error?: {
                /**
                 * @description Error message describing what went wrong. 
                 * @example Could not import MODELICA content, file must end with .mo or .zip.
                 */
                message?: string;
                /**
                 * @description Error code for identifying specific errors. 
                 * @example 12015
                 */
                code?: number;
              };
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteContentImport: {
    /**
     * Deletes a content import 
     * @description This API end point can be be called after a content has been imported.
     */
    responses: {
      /** @description OK: The content import with the specified ID was deleted. */
      200: never;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importFMU: {
    /** Imports an co-simulation FMU */
    /** @description The file with a .fmu extension and options to import. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The FMU file. 
           * @example PID.fmu
           */
          file: string;
          /**
           * @description Import options. 
           * @default {}
           */
          options: {
            /**
             * @description Qualified name of generated class. By default, 'className' is set to the name of the Modelica library content followed by a name based on the filename of the imported FMU. 
             * @example Workspace.Modelica_Electrical_Spice3_Examples_Spice3BenchmarkRtlInverter
             */
            className?: string;
            /**
             * @description Version of the Modelica standard library (MSL) that the target library is compatible with. This value must be a string of format 'x.y.z' where x,y and z are non-negative integers. Only MSL version 3.2.3 and above are supported. By default, the MSL version is set to 4.0.0. 
             * @example 4.0.0
             */
            mslVersion?: string;
            /** @description Determines if any already existing files in the library should be overwritten. By default, the existing files are not overwritten. */
            overwrite?: boolean;
            /**
             * @description Specifies what variables from the FMU to include in the wrapper model. By default, all the variables will be included in the wrapper model. 
             * @example [
             *   "variable1",
             *   "variable2"
             * ]
             */
            includePatterns?: (string)[];
            /**
             * @description Specifies what variables from the FMU to exclude in the wrapper model. By default, all the variables will be included in the wrapper model. 
             * @example [
             *   "variable1",
             *   "variable2"
             * ]
             */
            excludePatterns?: (string)[];
            /**
             * @description Specify which variables in the imported FMU will be inputs in the created Modelica wrapper model. By default, all the inputs are kept as inputs. 
             * @example [
             *   "variable1",
             *   "variable2"
             * ]
             */
            topLevelInputs?: (string)[];
            /**
             * @description Specifies the value for the 'step size' parameter in the generated model. By default, the parameter is set to zero, which in turn means that the step size will be set during simulation based on simulation properties such as the time interval. 
             * @example 0.1
             */
            stepSize?: number;
          };
        };
      };
    };
    responses: {
      /** @description FMU import created and location to check status of import is returned. */
      201: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The ID of the FMU import. 
               * @example api/projects/79sd8-3n2a4-e3t24/content/fd90-4gkl-vf89/fmu-imports/123d-4g56-67tr
               */
              location?: string;
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importFMUStatus: {
    /**
     * Returns status for a FMU import. Also returns data for the imported resource when ready 
     * @description The content needs to be setup for import by calling POST /fmu-imports, before calling this API endpoint.
     */
    responses: {
      /** @description Status for a FMU import and data to resource if import is done and FMU is ready to be used. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description ID for FMU import. 
               * @example 79sd8-3n2a4-e3t24
               */
              id?: string;
              /** @description Will be 'running' if import is on-going, 'ready' if import is finished and can be used, or 'error' if an error occured. */
              status?: string;
              /** @description Data for the FMU imported, only exists in response if FMU is imported and ready to use. Use the field 'status' to see if this is the case. */
              data?: {
                /**
                 * @description URI for the imported FMU resource. 
                 * @example api/projects/a9g0-adfd/contents/u760-u095-gu45
                 */
                resourceUri?: string;
                /**
                 * @description The modelica class path for the imported FMU. 
                 * @example Workspace.PID_Controller.Model
                 */
                fmuClassPath?: string;
                /**
                 * @description An array containing warnings generated during FMU import. 
                 * @example [
                 *   "Specified argument for 'top_level_inputs=['a']' does not match any variable"
                 * ]
                 */
                importWarnings?: (string)[];
              };
              /** @description Error message if the import fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
              error?: {
                /**
                 * @description Error message describing what went wrong. 
                 * @example Could not generate class MyPackage.PID because there is already a class by that name.
                 */
                message?: string;
                /**
                 * @description Error code for identifying specific errors. 
                 * @example 12099
                 */
                code?: number;
              };
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteFMUImport: {
    /**
     * Deletes a FMU import 
     * @description This API end point can be be called after a FMU has been imported.
     */
    responses: {
      /** @description OK: The FMU import with the specified ID was deleted. */
      200: never;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getExecutionOptionsProjects: {
    /**
     * Gets the execution options 
     * @description Gets the (aggregated) options for a custom function. This includes: Project specific options, options configured as defaults for the application, default options specified in the custom function. For options specified on multiple levels, the value is taken primarily from the project specific options, secondarily from the application default options and in third hand from the custom function default options.
     */
    responses: {
      /** @description The aggregated execution option set for a custom function. */
      200: {
        content: {
          "application/json": components["schemas"]["CaseExecutionOptions"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  putExecutionOptions: {
    /**
     * Sets execution option values 
     * @description The values for the options are saved for a specific custom function and workspace.
     */
    /** @description Execution options to set for custom function. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CaseExecutionOptions"];
      };
    };
    responses: {
      /** @description OK. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getDefaultExecutionOptionsProjects: {
    /**
     * Gets the default execution options 
     * @description Gets the application level default options for a custom function. This includes: Options configured as defaults for the application and default options specified in the custom function. For options specified on both levels, the value is taken from the application default options.
     */
    responses: {
      /** @description The application level default execution options for a custom function. */
      200: {
        content: {
          "application/json": components["schemas"]["CaseExecutionOptions"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getWorkspaceTemplate: {
    /**
     * Returns an object containing the template for the workspace. 
     * @description The response from this endpoint can be used as a template to create a new workspace by sending it as the request body for the POST /workspaces endpoint.
     */
    responses: {
      /** @description Workspace definition template. */
      200: {
        content: {
          "application/json": components["schemas"]["WorkspaceDefinitionCreationProtocol"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getWorkspaces: {
    /**
     * Returns an object containing a list of all available workspaces together with metadata 
     * @description The workspace ID in the returned object serve as unique IDs that can be used in other API calls to perform operations for a specific workspace.
     */
    responses: {
      /** @description All workspaces meta-data and their IDs. The object meta-data contains the workspace id and if the workspace is a clone. */
      200: {
        content: {
          "application/json": {
            data?: {
              items?: (components["schemas"]["Workspace"])[];
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  createWorkspace: {
    /**
     * Creates or imports a new workspace 
     * @description Creates a new workspace with some name.
     */
    /** @description Specification for creating a new workspace. */
    requestBody: {
      content: {
        "application/json": {
          new: components["schemas"]["WorkspaceDefinitionCreationProtocol"];
          /** @description Configuration options for creating the workspace. */
          config?: {
            /**
             * @description If true, creates a default project and adds it to the workspace. Also sets the project as the default project for the workspace if defaultProjectId is not set for the workpace. 
             * @default true
             */
            addDefaultProject: boolean;
            /**
             * @description If true, adds the system libraries(Modelica Standard Library and libraries stored in impact/libraries folder) as dependencies to the workspace. 
             * @default true
             */
            addSystemProjects: boolean;
          };
        };
      };
    };
    responses: {
      /** @description OK: Workspace added and the workspace was returned. */
      200: {
        content: {
          "application/json": components["schemas"]["Workspace"];
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteWorkspaces: {
    /**
     * Deletes from the workspace collection 
     * @description Used when not a specific workspace should be deleted but rather all workspaces with some attribute.
     */
    parameters?: {
        /**
         * @description Filter clones. 
         * @example true
         */
      query?: {
        clones?: boolean;
      };
    };
    responses: {
      /** @description OK: The targeted workspaces have been deleted. */
      200: never;
      /** @description OK: The targeted workspaces have been marked for deletion. */
      202: never;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getWorkspaceId: {
    /** Returns an object containing the metadata of the specified ID */
    responses: {
      /** @description Workspace ID and its meta-data. The object meta-data contains the workspace id and if the workspace is a clone. */
      200: {
        content: {
          "application/json": components["schemas"]["Workspace"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  increaseClonedWorkspaceTimestamp: {
    /**
     * Increase the timestamp of a cloned workspace 
     * @description Can be called periodically on a cloned workspace a client is working against. This will inform the system that this workspace is not inactive and may not be deleted.
     */
    responses: {
      /** @description OK: The timestamp was succesfully increased to the current time. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteWorkspace: {
    /** Deletes a workspace with the specified ID */
    responses: {
      /** @description OK: The workspace was deleted. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getWorkspaceConversionCheckId: {
    /** Returns what conversions are needed for a workspace and what potential issues there are */
    responses: {
      /** @description List of conversions that would occur if the POST /workspace-conversions was called. Also lists potential issues with conversions. These issues can be ignore by giving the ID when starting the conversion process. Note that this can lead to the converted workspace missing some content. */
      200: {
        content: {
          "application/json": {
            data: components["schemas"]["ConversionsChecksProtocol"];
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  cloneWorkspace: {
    /**
     * Creates a clone of a workspace 
     * @description A created clone of a workspace is a temporary resource. It can be used executing some workload based on resources of a workspace without mutating or adding anything to it.
     */
    responses: {
      /** @description OK: The workspace was cloned and the ID of the clone was returned. */
      200: {
        content: {
          "application/json": {
            /**
             * @description The name of the new cloned workspace. 
             * @example MyClonedWorkspace
             */
            workspace_id?: string;
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getWorkspaceDependencies: {
    /**
     * Get workspace dependencies 
     * @description Get workspace dependencies.
     */
    responses: {
      /** @description OK: The workspace dependencies were returned. */
      200: {
        content: {
          "application/json": {
            data?: {
              items?: (components["schemas"]["LocalProjectProtocol"])[];
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importWorkspaceDependency: {
    /**
     * Start import of a project and add it as a dependency to the workspace 
     * @description Will initiate import of a project and add it as a dependency to the workspace. After a successful completion of a call to this endpoint, call GET /workspaces/{workspace}/dependency-imports/{importId} to check status.
     */
    /** @description A mol or zip file given with multipart/form-data is used to import the project as dependency. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The mol or zip file. 
           * @example myProject.mol
           */
          file?: string;
        };
      };
    };
    responses: {
      /** @description Dependency import created and location to check status of import is returned. */
      201: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The location of the workspace dependency import. 
               * @example api/workspaces/MyWorkspace/dependency-imports/fd90-4gkl-vf89
               */
              location?: string;
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importWorkspaceDependencyStatus: {
    /**
     * Returns status for a dependency import. Also returns data for the imported resource when ready 
     * @description The project to be added as a dependency needs to be setup for import by calling POST /dependency-imports, before calling this API endpoint.
     */
    responses: {
      /** @description Status for a project import and data to resource if import is done and the project is ready to be used. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description ID for project import. 
               * @example 79sd8-3n2a4-e3t24
               */
              id?: string;
              /** @description Will be 'running' if import is on-going, 'ready' if import is finished and can be used, or 'error' if an error occured. */
              status?: string;
              /** @description Data for the project imported, only exists in response if project is imported and ready to use. Use the field 'status' to see if this is the case. */
              data?: {
                /**
                 * @description URI for the imported project resource. 
                 * @example api/projects/u760-u095-gu45
                 */
                resourceUri?: string;
                /**
                 * @description The ID for the imported project. 
                 * @example u760-u095-gu45
                 */
                projectId?: string;
              };
              /** @description Error message if the import fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
              error?: {
                /**
                 * @description Error message describing what went wrong. 
                 * @example Could not import project, file must end with .mol or .zip.
                 */
                message?: string;
                /**
                 * @description Error code for identifying specific errors. 
                 * @example 12015
                 */
                code?: number;
              };
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteWorkspaceDependencyImport: {
    /**
     * Deletes a workspace dependency import 
     * @description This API end point can be be called after a project has been imported and added as a workspace depenendency.
     */
    responses: {
      /** @description OK: The project import with the specified ID was deleted. */
      200: never;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importWorkspaceProject: {
    /**
     * Start import of an editable project to be added to the workspace 
     * @description Will initiate import of a project and add it to the workspace. After a successful completion of a call to this endpoint, call GET /workspaces/{workspace}/project-imports/{importId} to check status.
     */
    /** @description A zip file given with multipart/form-data is used to import the editable project. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The zip file. 
           * @example myProject.zip
           */
          file?: string;
        };
      };
    };
    responses: {
      /** @description Project import created and location to check status of import is returned. */
      201: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The location of the editable project import. 
               * @example api/workspaces/MyWorkspace/project-imports/fd90-4gkl-vf89
               */
              location?: string;
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importWorkspaceProjectStatus: {
    /**
     * Returns status for a project import. Also returns data for the imported resource when ready 
     * @description The editable project to be added to the workspace needs to be setup for import by calling POST /project-imports, before calling this API endpoint.
     */
    responses: {
      /** @description Status for a project import and data to resource if import is done and the project is ready to be used. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description ID for project import. 
               * @example 79sd8-3n2a4-e3t24
               */
              id?: string;
              /** @description Will be 'running' if import is on-going, 'ready' if import is finished and can be used, or 'error' if an error occured. */
              status?: string;
              /** @description Data for the project imported, only exists in response if project is imported and ready to use. Use the field 'status' to see if this is the case. */
              data?: {
                /**
                 * @description URI for the imported project resource. 
                 * @example api/projects/u760-u095-gu45
                 */
                resourceUri?: string;
                /**
                 * @description The ID for the imported project. 
                 * @example u760-u095-gu45
                 */
                projectId?: string;
              };
              /** @description Error message if the import fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
              error?: {
                /**
                 * @description Error message describing what went wrong. 
                 * @example Could not import project, file must end with .mol or .zip.
                 */
                message?: string;
                /**
                 * @description Error code for identifying specific errors. 
                 * @example 12015
                 */
                code?: number;
              };
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteWorkspaceProjectImport: {
    /**
     * Deletes a workspace project import 
     * @description This API end point can be be called after a project has been imported and added to the workspace.
     */
    responses: {
      /** @description OK: The project import with the specified ID was deleted. */
      200: never;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getWorkspaceProjects: {
    /**
     * Get workspace projects 
     * @description Get workspace projects.
     */
    responses: {
      /** @description OK: The workspace projects were returned. */
      200: {
        content: {
          "application/json": {
            data?: {
              items?: (components["schemas"]["LocalProjectProtocol"])[];
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getWorkspaceProjectExperiments: {
    /**
     * Get project generated experiments for a workspace. 
     * @description Get project generated experiments for a workspace.
     */
    responses: {
      /** @description The experiment setups and run info for all project generated experiments in a workspace. The objects contain the experiment ids, and additional values are what would be returned from GET /workspaces/{workspace}/experiments/{experimentId}. */
      200: {
        content: {
          "application/vnd.impact.experiment.v2+json": components["schemas"]["ExperimentListV2"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getWorkspaceProjectFmus: {
    /**
     * Get project generated FMUs for a workspace. 
     * @description Get project generated FMUs for a workspace.
     */
    responses: {
      /** @description The results and run info for all project generated FMUs in a workspace. The response objects contain the FMU ID and the additional fields are what would be returned from GET /workspaces/{workspace}/model-executables/{fmuId}. */
      200: {
        content: {
          "application/vnd.impact.model-executable.v2+json": components["schemas"]["ModelExecutableListV2"];
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getWorkspaceSharingId: {
    /**
     * Returns a workspaces sharing defintion 
     * @description Will create a workspace definition that can be shared with other users. This requires that all projects used in the workspace is either version controlled or a released projcet. The 'strict' query parameter can be used to specify if the version control URIs are to specific commits or not. The end-point /workspace-imports is used to import a workspace based on the shared definition returned from this end-point.
     */
    responses: {
      /** @description A workspace definition for sharing. */
      200: {
        content: {
          "application/json": {
            definition?: components["schemas"]["WorkspaceDefinitionProtocol"];
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getCustomFunction: {
    /**
     * Get the custom function meta-data 
     * @description Gets the meta-data for a custom function describing which parameters the custom function accepts (read more about the response for details). Note that the system comes with default custom functions thar are always available. Furthermore, you can read more about custom functions and setting up the system with your own in the Modelon Impact help center.
     */
    responses: {
      /** @description A custom function and its meta-data. */
      200: {
        content: {
          "application/json": {
            /**
             * @description Custom function signature schema version. 
             * @example 0.0.1
             */
            version?: string;
            /**
             * @description Name of the custom function. 
             * @example my_custom_function
             */
            name?: string;
            /**
             * @description Description of the custom function 
             * @example This is my custom function!
             */
            description?: string;
            /** @description Indicates whether the custom function support the 'initialize from' functionality when setting up an experiment. */
            can_initialize_from?: boolean;
            /** @description A list of parameters that should be supplied in the experiment definition if this custom function is used. */
            parameters?: ({
                /**
                 * @description Name of the custom function parameter. 
                 * @example my_custom_function_parameter
                 */
                name: string;
                /**
                 * @description Data type of the custom function parameter, supported types are 'Number', 'String', 'Boolean' and 'Enumeration'. 
                 * @example Number
                 */
                type: string;
                /**
                 * @description A list specifying values to choose the parameter from (applicable only for parameters of type Enumeration). 
                 * @example [
                 *   "small",
                 *   "medium",
                 *   "large"
                 * ]
                 */
                values?: (string)[];
                /**
                 * @description Description of the custom function parameter 
                 * @example This is my custom function parameter, supports values of '1', '2' and '3'
                 */
                description: string;
                /**
                 * @description If this custom function parameter is optional when calling this custom function, supported values are 'true' and 'false'. 
                 * @example true
                 */
                optional?: string;
                /**
                 * @description Default value for this custom function parameter, its data type should be as specified in 'type' (except for enumeration parameters, where the default value should be one of the enumerated values). 
                 * @example 2
                 */
                defaultValue?: string | number | boolean;
              })[];
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getExecutionOptions: {
    /**
     * Gets the execution options 
     * @description Gets the (aggregated) options for a custom function. This includes: Workspace specific options, options configured as defaults for the application, default options specified in the custom function. For options specified on multiple levels, the value is taken primarily from the workspace specific options, secondarily from the application default options and in third hand from the custom function default options.
     */
    responses: {
      /** @description The aggregated execution option set for a custom function. */
      200: {
        content: {
          "application/json": components["schemas"]["CaseExecutionOptions"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getDefaultExecutionOptions: {
    /**
     * Gets the default execution options 
     * @description Gets the application level default options for a custom function. This includes: Options configured as defaults for the application and default options specified in the custom function. For options specified on both levels, the value is taken from the application default options.
     */
    responses: {
      /** @description The application level default execution options for a custom function. */
      200: {
        content: {
          "application/json": components["schemas"]["CaseExecutionOptions"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getCustomFunctions: {
    /**
     * Get a list of custom functions meta-data 
     * @description Which custom functions that exists are useful when setting up an experiment using POST /workspaces/{workspace}/experiments. The name of a custom function is used for the field 'analysis_function' which specifies that it should be used for the experiment. The meta-data also describes which parameters each custom function accepts (read more about the response for details). Note that the system comes with default custom functions thar are always available. Furthermore, you can read more about custom functions and setting up the system with your own in the Modelon Impact help center.
     */
    responses: {
      /** @description A list of custom functions and their meta-data. */
      200: {
        content: {
          "application/json": {
            data?: {
              items?: ({
                  /**
                   * @description Custom function signature schema version. 
                   * @example 0.0.1
                   */
                  version: string;
                  /**
                   * @description Name of the custom function. 
                   * @example my_custom_function
                   */
                  name: string;
                  /**
                   * @description Description of the custom function 
                   * @example This is my custom function!
                   */
                  description: string;
                  /** @description Indicates whether the custom function support the 'initialize from' functionality when setting up an experiment. */
                  can_initialize_from: boolean;
                  /** @description A list of parameters that should be supplied in the experiment definition if this custom function is used. */
                  parameters: ({
                      /**
                       * @description Name of the custom function parameter. 
                       * @example my_custom_function_parameter
                       */
                      name: string;
                      /**
                       * @description Data type of the custom function parameter, supported types are 'Number', 'String', 'Boolean' and 'Enumeration'. 
                       * @example Number
                       */
                      type: string;
                      /**
                       * @description A list specifying values to choose the parameter from (applicable only for parameters of type Enumeration). 
                       * @example [
                       *   "small",
                       *   "medium",
                       *   "large"
                       * ]
                       */
                      values?: (string)[];
                      /**
                       * @description Description of the custom function parameter 
                       * @example This is my custom function parameter, supports values of '1', '2' and '3'
                       */
                      description: string;
                      /**
                       * @description If this custom function parameter is optional when calling this custom function, supported values are 'true' and 'false'. 
                       * @example true
                       */
                      optional?: string;
                      /**
                       * @description Default value for this custom function parameter, its data type should be as specified in 'type' (except for enumeration parameters, where the default value should be one of the enumerated values). 
                       * @example 2
                       */
                      defaultValue?: string | number | boolean;
                    })[];
                })[];
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getUnitConversionFactors: {
    /** Returns the set of unit conversion factors */
    responses: {
      /** @description A dictionary specifying the unit conversion factors for SI units and for imperial units. */
      200: {
        content: {
          "application/json": {
            /** @description SI unit conversions. */
            si?: ({
                /** @example K */
                unit: string;
                /** @example degC */
                displayUnit: string;
                /** @example 1 */
                multiplier: number;
                /** @example -273.15 */
                offset: number;
              })[];
            /** @description Imperial unit conversions. */
            imperial?: ({
                /** @example K */
                unit: string;
                /** @example degF */
                displayUnit: string;
                /** @example 1.8 */
                multiplier: number;
                /** @example -459.67 */
                offset: number;
              })[];
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getAllModelExecutableInfo: {
    /** Returns all model executables input and run info */
    parameters?: {
        /**
         * @description Modelica class path of the model. If given, only FMUs generated by the 'classPath' are returned. 
         * @example classPath=Modelica.Blocks.Examples.PID_Controller
         */
      query?: {
        classPath?: string;
      };
    };
    responses: {
      /** @description The results and run info for all compilations. The response objects contain the FMU ID and the additional fields are what would be returned from .../model-executables/{fmuId}. */
      200: {
        content: {
          "application/vnd.impact.model-executable.v2+json": components["schemas"]["ModelExecutableListV2"];
          "application/vnd.impact.model-executable.v1+json": components["schemas"]["ModelExecutableListV1"];
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  modelExecutableSetup: {
    /**
     * Sets up a model executable to be compiled 
     * @description The name of the model to be compiled is specified by the field 'class_name'. The remaining fields in the input are options for the compilation process. For a reference of what options can be used in the field 'compiler_options' and 'runtime_option' see the OCT User's Guide, which can be found in the Modelon Impact help center. If the FMU should be executed in Impact (rather than exported) it is recommended that 'fmi_target' is 'me', 'fmi_version' is '2.0' and 'platform' is 'auto'. If this end-point is called with the query parameter 'getCached' set to true, then a previously compiled model executable is returned, if such an FMU exists. To get a cached model executable (FMU) there must exists a successfully compiled model executable that was compiled with the same inputs as in the current call. Furthermore, if the Modelica model for which the FMU compilation is requested has been changed in a structural way, or at least one of its dependent models have changed, then a cached FMU will not be returned. Setting non-structural parameters and making graphical changes to the Modelica model will not break the cache for its compiled FMU.
     */
    parameters?: {
        /**
         * @description If true, returns, if available, a reusable model executable previously compiled. Also returns any non-structural parameters to be set on it. 
         * @example getCached=true
         */
        /**
         * @description If true, a cached FMU can be found even if the FMU was compiled with some non-structural parameters with unknown value. If this is the case, parametersMissing in the response will contain a list of these parameters and the caller should ensure to specify some values for these parameters when using the cached FMU. 
         * @example allowNonStructuralMissing=true
         */
      query?: {
        getCached?: string;
        allowNonStructuralMissing?: string;
      };
    };
    /** @description Compilation parameters. */
    requestBody: {
      content: {
        "application/json": {
          /** @description The input for how the compilation was done. */
          input: {
            /**
             * @description Model class name. 
             * @example Workspace.PID_Controller
             */
            class_name: string;
            /**
             * @description Key-value pairs of compilation options. 
             * @example {
             *   "generate_html_diagnostics": true
             * }
             */
            compiler_options: {
              [key: string]: (number | string | boolean) | undefined;
            };
            /**
             * @description Key-value pairs of run-time options. 
             * @example {
             *   "log_level": 4
             * }
             */
            runtime_options: {
              [key: string]: (number | string | boolean) | undefined;
            };
            /**
             * @description Compiler log level. 
             * @example info
             */
            compiler_log_level: string;
            /**
             * @description Flavour of the FMU. 
             * @example me 
             * @enum {string}
             */
            fmi_target: "me" | "cs" | "me+cs";
            /**
             * @description Version of FMI for the FMU. 
             * @example 2.0 
             * @enum {string}
             */
            fmi_version: "1.0" | "2.0";
            /**
             * @description Platform for FMU binary. 
             * @example win64 
             * @enum {string}
             */
            platform: "linux64" | "win32" | "win64" | "auto";
          };
        };
      };
    };
    responses: {
      /** @description An identifier for the FMU being compiled (ID). */
      200: {
        content: {
          "application/json": {
            /**
             * @description A unique identifier for an FMU. Will be null if getCached=true and no cached FMU is available. 
             * @example workspace_pid_controller_20090615_134530_as86g32
             */
            id?: string;
            /**
             * @description Parameter values to be set on the FMU referenced by the 'id', for it to represent current model setup. Empty if getCached=false. 
             * @example {
             *   "inertia1.J": 2
             * }
             */
            parameters?: Record<string, never>;
            /** @description Parameters to be set for the FMU referenced by the 'id', default value is otherwise not guaranteed to represent current model setup. Empty if getCached=false or allowNonStructuralMissing=false. */
            parametersMissing?: (string)[];
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getFmuPlatforms: {
    /**
     * Returns the supported platforms for FMU generation 
     * @description Can be used to find which values are supported for the field 'platform' when calling the POST method on '/workspaces/{workspace}/model-executables'.
     */
    responses: {
      /** @description A list of the supported FMU's generation platforms. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description An array containing the list of platforms in which the FMU can be generated. 
               * @example [
               *   "win32",
               *   "win64"
               * ]
               */
              platforms?: (string)[];
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getModelExecutableInfo: {
    /** Returns the compilation input and run info */
    responses: {
      /** @description The result from a compilation. The 'status' and 'errors' in 'run_info' should be checked to see if compilation finished successfully. */
      200: {
        content: {
          "application/vnd.impact.model-executable.v2+json": components["schemas"]["ModelExecutableItemV2"];
          "application/vnd.impact.model-executable.v1+json": components["schemas"]["ModelExecutableItemV1"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteModelExecutable: {
    /** Deletes the FMU with the specified ID */
    responses: {
      /** @description OK. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getCompilationStatus: {
    /** Get compilation status */
    responses: {
      /** @description Status of the compilation. */
      200: {
        content: {
          "application/json": {
            /**
             * @description Number of executions that have finished. Should not be used for determining if an execution is finished, instead use the 'status' string. 
             * @example 27
             */
            finished_executions?: number;
            /**
             * @description Total number of executions. 
             * @example 50
             */
            total_executions?: number;
            /**
             * @description Execution status, can have the values 'pending', 'running', 'stopping', 'cancelled' or 'done'. 
             * @example running
             */
            status?: string;
            /** @description An array containing progress information about all executions. */
            progresses?: ({
                /**
                 * @description A message about the progress of the execution. 
                 * @example Simulation at time 3.45
                 */
                message?: string;
                /**
                 * @description A number between 0 and 1 indicating how the execution is progressing. 
                 * @example 0.43
                 */
                percentage?: number;
                /**
                 * @description The stage this progress applies to. Possible values are 'simulation' and 'compilation'. 
                 * @example compilation
                 */
                stage?: string;
                /**
                 * @description True if the compilation is done. 
                 * @example true
                 */
                done?: boolean;
              })[];
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  modelExecutableCompile: {
    /**
     * Compiles a model 
     * @description First call POST /workspaces/{workspace}/model-executables to setup what should be compiled.
     */
    responses: {
      /** @description OK. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  cancelCompilation: {
    /** Cancel a running compilation */
    responses: {
      /** @description OK. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  downloadCompilationLog: {
    /** Downloads the model executable compilation log */
    responses: {
      /** @description A compilation log. */
      200: {
        content: {
          "text/plain": string;
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  downloadCompiledFMU: {
    /** Downloads an FMU binary that is compiled */
    responses: {
      /** @description An FMU file. */
      200: {
        content: {
          "application/zip": string;
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getFmuMeta: {
    /** Gets the FMU meta-data */
    /** @description The current parameter state of the FMU. */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description The current parameter state of the FMU. 
           * @example {
           *   "foo": 1,
           *   "bar": 2
           * }
           */
          parameterState: Record<string, never>;
        };
      };
    };
    responses: {
      /** @description The FMU meta-data. */
      200: {
        content: {
          "application/json": {
            /** @description The steady state meta-data. */
            steady_state?: {
              /**
               * @description Number of residual variables. 
               * @example 1
               */
              residual_variable_count?: number;
              /**
               * @description Number of iteration variables. 
               * @example 2
               */
              iteration_variable_count?: number;
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getFmuParameters: {
    /**
     * Gets the parameters that can be set on the FMU 
     * @description Can be used to find what parameters are feasible to have as modifiers in an experiment.
     */
    responses: {
      /** @description A list of the FMU's settable parameters. */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getFmuStringParametersAndValues: {
    /**
     * Gets parameters that have string values together with those values 
     * @description Gets a list of parameters whose values are strings and one list with respective value in order. Can be used when requiring string parameters that don't come with the result.
     */
    responses: {
      /** @description An object containing a list of two lists. The first list is the names of the parameters, and the second is a list of the parameter values in the same order. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description An array containing two arrays, the first containing parameter names and the second containing respective string values. 
               * @example [
               *   [
               *     "var1",
               *     "var2"
               *   ],
               *   [
               *     "val1",
               *     "val2"
               *   ]
               * ]
               */
              items?: ((string)[])[];
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getAllExperimentInfo: {
    /** Get all experiments meta-data */
    parameters?: {
        /**
         * @description Modelica class path of the model. If given, only experiments generated by the 'classPath' are returned. 
         * @example classPath=Modelica.Blocks.Examples.PID_Controller
         */
      query?: {
        classPath?: string;
      };
    };
    responses: {
      /** @description The experiment setups and run info for all experiments. The objects contain the experiment ids, and additional values are what would be returned from .../experiments/{experimentId}. */
      200: {
        content: {
          "application/vnd.impact.experiment.v2+json": components["schemas"]["ExperimentListV2"];
          "application/vnd.impact.experiment.v1+json": components["schemas"]["ExperimentListV1"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  setupExperiment: {
    /**
     * Sets up an experiment for execution 
     * @description The required inputs for setting up a multi-execution experiment is either 'id' in 'base/model/fmu' OR 'className' in 'base/model/modelica', along with 'type' in 'base/analysis'. These can be obtained from POST /workspaces/{workspace}/model-executables and GET /workspaces/{workspace}/custom-functions respectively. The FMU 'id' specifies what FMU the experiment is based on, and analysis 'type' specifies what analysis custom function is used for each case of the experiment. Furthermore, experiments support multi-execution, i.e., batch computations where each case executes a custom function. Multi-execution experiments can be set up in two ways.
     * 
     * The first way to setup multi-execution experiments is to specify 'operators' for 'modifiers' which are applied to the base experiment. An example experiment for this could contain the 'modifiers': {'variables': {'x': 'range(1, 2, 3)'}}, which would result in a multi-execution experiment with three cases: x=1, x=1.5, and x=2. Note that if multiple 'operators' are used for different variables, the experiment will be expand to cases with all combinations of parametrizations, i.e., full factorial is used to expand the experiment. Here is a full example using the range operator to create cases:
     * 
     * <pre>
     * {
     *   "experiment": {
     *     "version": 2,
     *     "base": {
     *       "model": {
     *         "fmu": {
     *           "id": "workspace_pid_controller_20090615_134530_as86g32"
     *         }
     *       },
     *       "modifiers": {
     *         "variables": {
     *           "inertia1.J": "range(1, 2, 10)",
     *         }
     *       },
     *       "analysis": {
     *         "type": "dynamic",
     *         "parameters": {
     *           "start_time": 0,
     *           "final_time": 1
     *         }
     *       }
     *     }
     *   }
     * }
     * </pre>
     * 
     * The other way of defining an experiment is to specify 'extensions' to the 'base' definition, where each 'extension' is combined with 'base' to create a case. For example, an experiment with the 'extensions': [{'modifiers': {'variables': {'x': 1}}}, {'modifiers': {'variables': {'x': 1.5}}}, {'modifiers': {'variables': {'x': 2}}}], would result in the same multi-execution as above (if no modifiers are defined in 'base'). This way of creating cases gives more freedom to the client to set up a multi-execution experiment, since cases are defined by parameter configurations, as opposed to operators (like the range operator). This approach also allows different options and custom function parameters to be used for the different cases. These two methods of setting up a multi-execution cannot be combined. So, if any extensions are given, it is not allowed to include any 'operators' anywhere in the experiment. It is however allowed to provide parameter values (with no operators) in 'base' in combination with defining cases with 'extensions'. In this case, parameters set in 'extensions' overrides those set in 'base'.
     * 
     * The following example shows how 'extensions' are used to set options and parameters for separate cases and thereby overriding the values in the 'base' definition. The 'base' definition in the example have 'analysis': {'type': 'dynamic', 'parameters': {'start_time': 2, 'final_time': 3}}, and 'modifiers': {'variables': {'x': 1, 'y': 3}}}. If used with the 'extensions':
     * 
     * [{'analysis': {'parameters': {'final_time': 4}}}, 'modifiers': {'variables': {'y': 5}}}, {'analysis': {'parameters': {'start_time': 1}}}, 'modifiers': {'variables': {'x': 2}}}],
     * 
     * we will get two cases. The first case will use 2 for 'start_time' from the 'base' and 4 for 'final_time' as it is overridden by the 'extension', in the same way it will use 'x'=1 and 'y'=5 as modifiers. The second case overrides 'start_time' and 'x' and will result in 'start_time'=1, 'final_time'=3, 'x'=2, and 'y'=3.
     * 
     * The old (version 1) experiment format can still be used but will be removed in a future version.
     */
    /** @description Experiment parameters. */
    requestBody: {
      content: {
        "application/vnd.impact.experiment.v2+json": {
          experiment: components["schemas"]["ExperimentDefinition"];
          /**
           * @description Up to 2048 bytes of custom data to be associated with the experiment. 
           * @example {
           *   "parametrizationFrom": "specification 3.4",
           *   "externalToolVersion": "9.0"
           * }
           */
          userData?: Record<string, never>;
        };
        "application/vnd.impact.experiment.v1+json": {
          experiment: {
            /**
             * @description Reference ID to the compiled model. 
             * @example workspace_pid_controller_20090615_134530_as86g32
             */
            fmu_id: string;
            /**
             * @example {
             *   "variables": {
             *     "integrator.k": 1,
             *     "inertia1.J": "range(1,5,5)",
             *     "inertia2.J": "range(5,10,3)"
             *   },
             *   "initializeFrom": ""
             * }
             */
            modifiers?: {
              /** @description Specifies parameter values and ranges. The range operator allows a range of values to be described: e.g. range(0,1,5) describes 5 evenly spaced values between 0 and 1: [0,0.25,0.5,0.75,1]. If multiple range operators are specified a full factorial is used to determine all different parameterizations for the experiment. */
              variables?: {
                [key: string]: (number | string | boolean) | undefined;
              };
              /** @description Initialize the simulation using values from a previous simulation by giving the corresponding experiment ID. The experiment used must be for a simulation with a single case, otherwise 'initializeFromCase' must be used. Details on how the initialization is done depend on the custom function. */
              initializeFrom?: string;
            };
            /** @description The analysis object. */
            analysis: {
              /**
               * @description The name of the custom function that will be executed. 
               * @example dynamic
               */
              analysis_function: string;
              /**
               * @description Parameters to the custom function. 
               * @example {
               *   "start_time": 0,
               *   "final_time": 1
               * }
               */
              parameters?: {
                [key: string]: (number | string | boolean) | undefined;
              };
              /** @description Key-value pairs of simulation options. */
              simulation_options?: {
                [key: string]: (number | string | boolean) | undefined;
              };
              /** @description Key-value pairs of solver options. */
              solver_options?: {
                [key: string]: (number | string | boolean) | undefined;
              };
              /**
               * @description The simulation log level. 
               * @default WARNING 
               * @enum {string}
               */
              simulation_log_level: "NOTHING" | "FATAL" | "ERROR" | "WARNING" | "INFO" | "VERBOSE" | "DEBUG" | "ALL";
            };
          };
          /**
           * @description Up to 2048 bytes of custom data to be associated with the experiment. 
           * @example {
           *   "parametrizationFrom": "specification 3.4",
           *   "externalToolVersion": "9.0"
           * }
           */
          userData?: Record<string, never>;
        };
      };
    };
    responses: {
      /** @description An identifier for the experiment (ID). */
      200: {
        content: {
          "application/json": {
            /**
             * @description An object with an unique identifier for this experiment, used to track this experiment in other API calls. 
             * @example workspace_pid_controller_20090615_134530_as86g32
             */
            experiment_id?: string;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getExperimentInfo: {
    /** Get experiment information */
    responses: {
      /** @description The experiment information as JSON. */
      200: {
        content: {
          "application/vnd.impact.experiment.v2+json": {
            /** @example workspace_pid_controller_20200705_170234_546ccba */
            id?: string;
            experiment?: components["schemas"]["ExperimentDefinition"];
            meta_data?: components["schemas"]["ExperimentMetaData"];
            run_info?: {
              /**
               * @description String that is 'cancelled', 'failed' or 'done' depending on if all parts of the experiment could run. 
               * @example failed
               */
              status?: string;
              /**
               * @description An array containing errors if status is 'failed'. 
               * @example [
               *   "Current settings will generate a large amount of simulation cases. Try reducing the number of simulation cases."
               * ]
               */
              errors?: (string)[];
              /**
               * @description Number of cases that are failed. 
               * @example 0
               */
              failed?: number;
              /**
               * @description Number of cases that are successful. 
               * @example 2
               */
              successful?: number;
              /**
               * @description Number of cases that are not started. 
               * @example 0
               */
              not_started?: number;
              /**
               * @description Number of cases that are cancelled. 
               * @example 0
               */
              cancelled?: number;
            };
          };
          "application/vnd.impact.experiment.v1+json": {
            /** @example workspace_pid_controller_20200705_170234_546ccba */
            id?: string;
            experiment?: {
              /**
               * @description Reference ID to the compiled model. 
               * @example workspace_pid_controller_20090615_134530_as86g32
               */
              fmu_id: string;
              /**
               * @example {
               *   "variables": {
               *     "integrator.k": 1,
               *     "inertia1.J": "range(1,5,5)",
               *     "inertia2.J": "range(5,10,3)"
               *   },
               *   "initializeFrom": ""
               * }
               */
              modifiers?: {
                /** @description Specifies parameter values and ranges. The range operator allows a range of values to be described: e.g. range(0,1,5) describes 5 evenly spaced values between 0 and 1: [0,0.25,0.5,0.75,1]. If multiple range operators are specified a full factorial is used to determine all different parameterizations for the experiment. */
                variables?: {
                  [key: string]: (number | string | boolean) | undefined;
                };
                /** @description Initialize the simulation using values from a previous simulation by giving the corresponding experiment ID. The experiment used must be for a simulation with a single case, otherwise 'initializeFromCase' must be used. Details on how the initialization is done depend on the custom function. */
                initializeFrom?: string;
              };
              /** @description The analysis object. */
              analysis: {
                /**
                 * @description The name of the custom function that will be executed. 
                 * @example dynamic
                 */
                analysis_function: string;
                /**
                 * @description Parameters to the custom function. 
                 * @example {
                 *   "start_time": 0,
                 *   "final_time": 1
                 * }
                 */
                parameters?: {
                  [key: string]: (number | string | boolean) | undefined;
                };
                /** @description Key-value pairs of simulation options. */
                simulation_options?: {
                  [key: string]: (number | string | boolean) | undefined;
                };
                /** @description Key-value pairs of solver options. */
                solver_options?: {
                  [key: string]: (number | string | boolean) | undefined;
                };
                /**
                 * @description The simulation log level. 
                 * @default WARNING 
                 * @enum {string}
                 */
                simulation_log_level: "NOTHING" | "FATAL" | "ERROR" | "WARNING" | "INFO" | "VERBOSE" | "DEBUG" | "ALL";
              };
            };
            meta_data?: components["schemas"]["ExperimentMetaData"];
            run_info?: {
              /**
               * @description String that is 'cancelled', 'failed' or 'done' depending on if all parts of the experiment could run. 
               * @example failed
               */
              status?: string;
              /**
               * @description An array containing errors if status is 'failed'. 
               * @example [
               *   "Current settings will generate a large amount of simulation cases. Try reducing the number of simulation cases."
               * ]
               */
              errors?: (string)[];
              /**
               * @description Number of cases that are failed. 
               * @example 0
               */
              failed?: number;
              /**
               * @description Number of cases that are successful. 
               * @example 2
               */
              successful?: number;
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  setLabel: {
    /**
     * Set a label for an experiment 
     * @description Can be used to set a human readable identifier for an experiment.
     */
    /** @description The new label for the experiment. */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The new label for the experiment. 
           * @example tuning of P part
           */
          label: string;
        };
      };
    };
    responses: {
      /** @description OK. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  removeExperiment: {
    /** Removes an experiment */
    responses: {
      /** @description OK. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getExecutionStatus: {
    /** Get execution status */
    responses: {
      /** @description Status. */
      200: {
        content: {
          "application/json": {
            /**
             * @description Number of executions that have finished. Should not be used for determining if an execution is finished, instead use the 'status' string. 
             * @example 27
             */
            finished_executions?: number;
            /**
             * @description Total number of executions. 
             * @example 50
             */
            total_executions?: number;
            /**
             * @description Execution status, can have the values 'pending', 'running', 'stopping', 'cancelled' or 'done'. 
             * @example running
             */
            status?: string;
            /** @description An array containing progress information about all executions. */
            progresses?: ({
                /**
                 * @description A messag about the progress of the exectuion. 
                 * @example Simulation at time 3.45
                 */
                message?: string;
                /**
                 * @description A number between 0 and 1 indicating how the execution is progressing. 
                 * @example 0.43
                 */
                percentage?: number;
                /**
                 * @description The stage this progress applies to. Possible values are 'simulation' and 'compilation'. 
                 * @example compilation
                 */
                stage?: string;
                /**
                 * @description True if the execution is done. 
                 * @example true
                 */
                done?: boolean;
              })[];
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  execute: {
    /**
     * Executes an experiment 
     * @description First call POST /workspaces/{workspace}/experiments to setup what should be executed.
     */
    /** @description Optional request body for how execution should run. */
    requestBody?: {
      content: {
        "application/json": {
          /** @description The cases to include in the execution. */
          includeCases?: {
            /** @description List of cases to execute. */
            ids?: (string)[];
          };
          /** @description Options for how the execution is run. */
          options?: {
            /**
             * @description If true, then compilation will always be done even if a previous compilation result could be used. Default is false. 
             * @example true
             */
            forceCompilation?: boolean;
          };
        };
      };
    };
    responses: {
      /** @description The experiment is executed. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  cancelExecution: {
    /** Cancel a running execution */
    responses: {
      /** @description The experiment is cancelled. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getAllCaseInfo: {
    /** Get all cases meta-data */
    responses: {
      /** @description The case information as JSON. */
      200: {
        content: {
          "application/json": {
            data?: {
              items?: ({
                  /**
                   * @description Case ID. 
                   * @example case_1
                   */
                  id?: string;
                  meta?: {
                    /**
                     * @description Case label. 
                     * @example Cruise operating point
                     */
                    label?: OneOf<[string, null]>;
                  };
                  run_info?: {
                    /**
                     * @description Status of the case run, can be 'successful', 'failed', 'not_started' or 'cancelled'. 
                     * @example successful
                     */
                    status?: string;
                    /**
                     * @description At which stage the case failed if 'status' is 'failed', can be 'simulation' or 'compilation'. If 'status' is not 'failed' it will be null. 
                     * @example simulation
                     */
                    failed_at?: string;
                    /**
                     * @description The unix time the case started running. 
                     * @example 1549552749
                     */
                    datetime_started?: number;
                    /**
                     * @description The unix time the case finshed running. 
                     * @example 1549552338
                     */
                    datetime_finished?: number;
                  };
                  input?: {
                    /**
                     * @description Reference ID to the compiled model used running the case. 
                     * @example workspace_pid_controller_20090615_134530_as86g32
                     */
                    fmu_id?: string;
                    /** @description The analysis object. */
                    analysis?: {
                      /**
                       * @description the name of the custom function. 
                       * @example dynamic
                       */
                      analysis_function: string;
                      /**
                       * @description parameters to the custom function. 
                       * @example {
                       *   "start_time": 0,
                       *   "final_time": 1
                       * }
                       */
                      parameters?: Record<string, never>;
                      /** @description Key-value pairs of simulation options. */
                      simulation_options?: Record<string, never>;
                      /** @description Key-value pairs of solver options. */
                      solver_options?: Record<string, never>;
                    };
                    /** @description Parameterization of the case, a list of key value pairs where key is variable name and value is the value to use for that variable. */
                    parametrization?: Record<string, never>;
                    /** @description Structural parameterization of the case, a list of key value pairs where key is variable name and value is the value to use for that variable. These are values that cannot be applied to the FMU/Model after compilation. */
                    structural_parametrization?: Record<string, never>;
                    /** @description This is some base parametrization that must be applied to the FMU for it to be valid running this case. It often comes as a result from of caching to reuse the FMU. */
                    fmu_base_parametrization?: Record<string, never>;
                  };
                })[];
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getCaseInfo: {
    /** Get case information */
    responses: {
      /** @description Case information. */
      200: {
        content: {
          "application/json": components["schemas"]["Case"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  putCaseInfo: {
    /**
     * Update case information 
     * @description This end-point can be used to update a case input. This can be used to modify the case and then execute the case again as part of an experiment and get different results for the case. Only fields under 'input' and 'meta' can be updated. Also, the fields 'fmu_id', 'analysis_function', 'structural_parametrization' and 'fmu_base_parametrization' cannot be updated. After a case is updated the 'consistent' field will be set to 'false' to signify that case results might not match the case input. Executing the case as part of an experiment will set 'consistent' to 'true'. The recomended way to update the case is to first use the corresponding GET end-point, modify some data, then call PUT (this end-point) with that data.
     */
    /** @description Case information. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Case"];
      };
    };
    responses: {
      /** @description The case is updated. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getCaseLog: {
    /** Get the log for a finished case */
    responses: {
      /** @description The case log. */
      200: {
        content: {
          "text/plain": string;
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getCaseResults: {
    /** Download the result file for a finished case */
    responses: {
      /** @description A file containing the experiment result for this case. */
      200: {
        content: {
          "application/vnd.impact.mat.v1+octet-stream": string;
          "text/csv": string;
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getCaseTrajectories: {
    /**
     * Get the trajectories for specified variables from the experiment result for a finished case 
     * @description This end-point can be used to fetch trajectories from cases that have finished executing. The trajectories are then typically used to visualize the result by plotting variables as a function of time or as X-Y plots. Which variables exists in a result can be obtained from the end-point GET /workspaces/{workspace}/experiments/{experimentId}/variables. Most experiments contain the independent variable 'time', with the custom function 'dynamic' being a notable example of this. So, to plot 'x' against 'time' for an experiment with a single case and the custom function 'dynamic', call this end-point with the input {'variable_names': ['x', 'time']} and plot 'item' 1 against 'item' 2 from the response. See the response description for more details on the structure of the response. The old (version 1) trajectory format can still be used but will be removed in a future version.
     */
    parameters?: {
        /**
         * @description If true, converts the values 'Infinity', '-Infinity' and 'NaN' to strings before returning the response. 
         * @example asStrings=true
         */
      query?: {
        asStrings?: string;
      };
    };
    /** @description A list of variable names for which the trajectories should be returned. */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The variable names trajectories should be fetched for. 
           * @example [
           *   "variable1",
           *   "variable2"
           * ]
           */
          variable_names: (string)[];
        };
      };
    };
    responses: {
      /** @description Experiment results for each variable in request body. */
      200: {
        content: {
          "application/vnd.impact.trajectories.v2+json": {
            data?: {
              items?: ({
                  /**
                   * @description If true, the trajectory does not vary with 'time' and only a single value is returned. 
                   * @example false
                   */
                  fixed?: boolean;
                  /**
                   * @description The result trajectory for a variable, is an array of values. 
                   * @example [
                   *   1,
                   *   2,
                   *   3,
                   *   4
                   * ]
                   */
                  trajectory?: (number | string)[];
                })[];
            };
          };
          "application/vnd.impact.trajectories.v1+json": ((number | string)[])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getCustomArtifact: {
    /** Get an artifact for a case as stored by the custom function used for running the case */
    responses: {
      /** @description An artifact for this case. */
      200: {
        content: {
          "application/octet-stream": string;
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getVariables: {
    /** Get all variables in the experiment result */
    responses: {
      /** @description An array of variable names. */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getTrajectories: {
    /**
     * Get the trajectories for specified variables from the experiment result 
     * @description This end-point can be used to fetch trajectories from experiments that has finished executing. The trajectories are then typically used to visualize the result by plotting variables as a function of time or as X-Y plots. Which variables exists in a result can be obtained from the end-point GET /workspaces/{workspace}/experiments/{experimentId}/variables. Most experiments contain the independent variable 'time', with the custom function 'dynamic' being a notable example of this. So, to plot 'x' against 'time' for an experiment with a single case and the custom function 'dynamic', call this end-point with the input {'variable_names': ['x', 'time']} and plot 'item' 1 against 'item' 2 under 'case_1' in the response. See the response description for more details on the structure of the response. The old (version 1) trajectory format can still be used but will be removed in a future version.
     */
    parameters?: {
        /**
         * @description If true, converts the values 'Infinity', '-Infinity' and 'NaN' to strings before returning the response. 
         * @example asStrings=true
         */
      query?: {
        asStrings?: string;
      };
    };
    /** @description A list of variable names for which the trajectories should be returned. */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The variable names trajectories should be fetched for. 
           * @example [
           *   "variable1",
           *   "variable2"
           * ]
           */
          variable_names: (string)[];
        };
      };
    };
    responses: {
      /** @description Experiment results for all cases of experiment and for each variable in request body. */
      200: {
        content: {
          "application/vnd.impact.trajectories.v2+json": {
            data?: {
              items?: ({
                  /**
                   * @description The case ID for which corresponding data in 'items' belong to. 
                   * @example case_1
                   */
                  caseId?: string;
                  /** @description Trajectories for all variables given in request body for one case. */
                  items?: ({
                      /**
                       * @description If true, the trajectory does not vary with 'time' and only a single value is returned. 
                       * @example false
                       */
                      fixed?: boolean;
                      /**
                       * @description The result trajectory for a variable, is an array of values. 
                       * @example [
                       *   1,
                       *   2,
                       *   3,
                       *   4
                       * ]
                       */
                      trajectory?: (number | string)[];
                    })[];
                })[];
            };
          };
          "application/vnd.impact.trajectories.v1+json": (((number | string)[])[])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  prepareExportWorkspaceAsync: {
    /**
     * Prepares a workspace for download as a zip file 
     * @description The compressed workspace will be prepared. After a successful completion of a call to this endpoint, call GET /workspace-exports/{exportId} to check status.
     */
    /** @description Specification of what workspace resources to include when exporting the workspace. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceExportCreationProtocol"];
      };
    };
    responses: {
      /** @description The location for checking status and possible data for compressed workspace. */
      201: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description location for checking status of workspace compression. 
               * @example api/workspace-exports/79sd8-3n2a4-e3t24
               */
              location?: string;
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  exportWorkspaceAsync: {
    /**
     * Returns status for preparing a workspace for download. Also returns data for download when ready 
     * @description The workspace needs to be setup for export by calling POST /workspace-exports, before calling this API endpoint.
     */
    responses: {
      /** @description Status for a workspace export and data to download it if ready. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description ID for workspace export. 
               * @example 79sd8-3n2a4-e3t24
               */
              id?: string;
              /** @description Will be 'running' if export is on-going, 'ready' if export is finished and can be downloaded, or 'error' if an error occured. */
              status?: string;
              /** @description Data for the workspace to download, only exists in response if workspace is ready to be downloaded. Use the field 'status' to see if this is the case. */
              data?: {
                /**
                 * @description URI for downloading the workspace. 
                 * @example api/exports/79sd8-3n2a4-e3t24
                 */
                downloadUri?: string;
                /**
                 * @description The size of the compressed workspace, in bytes. 
                 * @example 10481015
                 */
                size?: number;
              };
              /** @description Error message if the export fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
              error?: {
                /**
                 * @description Error message describing what went wrong. 
                 * @example Could not export workspace 'my_workspace'. Maximum allowed zip file size of 95MB exceeded
                 */
                message?: string;
                /**
                 * @description Error code for identifying specific errors. 
                 * @example 12072
                 */
                code?: number;
              };
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteExportedWorkspaceAsync: {
    /**
     * Deletes a workspace export, including the compressed zip 
     * @description This API end point can be be called after a compressed workspace has been downloaded.
     */
    responses: {
      /** @description OK: The workspace export with the specified ID was deleted. */
      200: never;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importWorkspace: {
    /**
     * Start import of an existing workspace 
     * @description Will initiate import of an existing workspace. After a successful completion of a call to this endpoint, call GET /workspace-imports/{importId} to check status.
     */
    /** @description Either a zip file of a workspace given with multipart/form-data or JSON schema for workspace definition (and optional selected matchings) to import a workspace. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The zip-file. 
           * @example my_workspace.zip
           */
          file?: string;
        };
        "application/json": {
          definition: components["schemas"]["WorkspaceDefinitionProtocol"];
          selectedMatchings?: components["schemas"]["SelectedMatchingsProtocol"];
        };
      };
    };
    responses: {
      /** @description Workspace import created and location to check status of import is returned. */
      201: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The ID of the workspace import. 
               * @example api/workspace-imports/fd90-4gkl-vf89
               */
              location?: string;
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importWorkspaceStatus: {
    /**
     * Returns status for a workspace import. Also returns data for the imported resource when ready 
     * @description The workspace needs to be setup for import by calling POST /workspace-imports, before calling this API endpoint.
     */
    responses: {
      /** @description Status for a workspace import and data to resource if import is done and workspace is ready to be used. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description ID for workspace import. 
               * @example 79sd8-3n2a4-e3t24
               */
              id?: string;
              /** @description Will be 'running' if import is on-going, 'ready' if import is finished and can be used, or 'error' if an error occured. */
              status?: string;
              /** @description Data for the workspace imported, only exists in response if workspace is imported and ready to use. Use the field 'status' to see if this is the case. */
              data?: {
                /**
                 * @description URI for the imported workspace resource. 
                 * @example api/workspaces/my_workspace
                 */
                resourceUri?: string;
                /**
                 * @description The ID for the workspace imported. 
                 * @example my_workspace
                 */
                workspaceId?: string;
              };
              /** @description Error message if the import fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
              error?: {
                /**
                 * @description Error message describing what went wrong. 
                 * @example Could not import workspace 'my_workspace'. Could not read version number of the workspace 'my_workspace'. Either the workspace is corrupt or needs to be updated using an older version of Modelon Impact
                 */
                message?: string;
                /**
                 * @description Error code for identifying specific errors. 
                 * @example 12015
                 */
                code?: number;
              };
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteWorkspaceImport: {
    /**
     * Deletes a workspace import 
     * @description This API end point can be be called after a workspace has been imported.
     */
    responses: {
      /** @description OK: The workspace import with the specified ID was deleted. */
      200: never;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importWorkspaceMatchings: {
    /**
     * Get all projects matchings for workspace import 
     * @description Get all projects matchings that would happen during a workspace import. As import will fail if there are multiple possible matchings of local projects for a project, this end-point is used to get these matchings which can be resolved to an unequivocal 'selection'. Selections are used as (optional) input to the end-point /workspace-imports, see it for more details on the format of a selection.
     */
    /** @description The shared workspace definition to check for matchings that would happen during import. */
    requestBody: {
      content: {
        "application/json": {
          definition?: components["schemas"]["WorkspaceDefinitionProtocol"];
        };
      };
    };
    responses: {
      /** @description Matchings that would happen during import. */
      200: {
        content: {
          "application/json": {
            data?: {
              vcs?: (components["schemas"]["VcsMatchingProtocol"])[];
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  prepareWorkspaceConversionAsync: {
    /**
     * Starts a workspace conversion 
     * @description Will start a conversion of a workspace. A backup can optionally be made as part this conversion. As conversions are non-reversible it is recommended to create and keep a backup over a transition period. After a successful completion of a call to this endpoint, call GET /workspace-conversions/{conversionId} to check status.
     */
    /** @description Specification of what workspace to convert and optional backup. */
    requestBody: {
      content: {
        "application/json": {
          data: components["schemas"]["ConversionSpecProtocol"];
        };
      };
    };
    responses: {
      /** @description The location for checking status and possible data for converted workspace. */
      201: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description location for checking status of workspace conversion. 
               * @example api/workspace-conversions/79sd8-3n2a4-e3t24
               */
              location?: string;
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  workspaceConversionStatusAsync: {
    /**
     * Returns status for workspace conversion 
     * @description The workspace needs to be setup for conversion by calling POST /workspace-conversions, before calling this API endpoint.
     */
    responses: {
      /** @description Status for a workspace conversion. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description ID for workspace conversion. 
               * @example 79sd8-3n2a4-e3t24
               */
              id?: string;
              /** @description Will be 'running' if conversion is on-going, 'ready' if conversion is finished and workspace can be used, or 'error' if an error occured. */
              status?: string;
              /** @description Data for the workspace converted, only exists in response if workspace is ready. Use the field 'status' to see if this is the case. */
              data?: {
                /**
                 * @description URI for downloading the workspace. 
                 * @example api/workscapes/my_workspace
                 */
                downloadUri?: string;
                /**
                 * @description Id of workspace that has been converted. 
                 * @example my_workspace
                 */
                workspaceId?: string;
              };
              /** @description Error message if the conversion fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
              error?: {
                /**
                 * @description Error message describing what went wrong. 
                 * @example Could not convert workspace 'my_workspace'. Workspace 'my_workspace' does not exist
                 */
                message?: string;
                /**
                 * @description Error code for identifying specific errors. 
                 * @example 12013
                 */
                code?: number;
              };
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deletedWorkspaceConversionAsync: {
    /**
     * Deletes a workspace conversion 
     * @description This API end point can be be called after a workspace conversion is finished. Will not delete any created backups or revert any changes from on-going conversion.
     */
    responses: {
      /** @description OK: The workspace conversion with the specified ID was deleted. */
      200: never;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  exportFile: {
    /**
     * Downloads a file that has been setup to be exported 
     * @description This route is used for downloading exported files. Other end-points will reference here with a download URI.
     */
    responses: {
      /** @description A file to download. */
      200: {
        content: {
          "application/zip": string;
        };
      };
      /** @description The resource cannot be downloaded. Most likely, something went wrong when creating the zip file. */
      400: {
        content: {
          "application/json": {
            error?: {
              /**
               * @description Error message describing what went wrong. 
               * @example Could not export workspace 'ceb6ac1ed71040eb8f3df7f69157e658', reason: 'Maximum allowed zip file size of 95MB exceeded'
               */
              message?: string;
              /**
               * @description Error code for identifying specific errors. 
               * @example 12072
               */
              code?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  uploadMAT: {
    /** Imports an result file */
    /** @description The file with a .mat extension and options to import. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The result file in question. 
           * @example result_1.mat
           */
          file: string;
          /** @description Upload options. */
          options: {
            /**
             * @description Meaningful label for results association. If not given the name of the file uploaded will be used. 
             * @example result_for_PID.mat
             */
            name?: string;
            /**
             * @description Description of the result. If not given an empty string will be used 
             * @example This is a result file for PID controller
             */
            description?: string;
            /** @description Context describing the model and associated values. */
            context: {
              /**
               * @description Workspace id. 
               * @example my_workspace
               */
              workspaceId: string;
            };
          };
        };
      };
    };
    responses: {
      /** @description OK. The result has been uploaded to the workspace. */
      201: {
        content: {
          "application/json": components["schemas"]["ExternalResultUploadStatus"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getUploadStatus: {
    /**
     * Get the current status of upload 
     * @description Get the current status of upload for a given uploadId.
     */
    responses: {
      /** @description OK. Check status of upload. */
      200: {
        content: {
          "application/json": components["schemas"]["ExternalResultUploadStatus"];
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getUploadedResultEntity: {
    /**
     * Get the result file meta-data 
     * @description Gets the meta-data for a result file.
     */
    responses: {
      /** @description External result meta-data. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description Id for result storage. 
               * @example 2f036b9fab6f45c788cc466da327cc78workspace
               */
              id?: string;
              /**
               * @description Timestamp of when the external result was imported. 
               * @example 2021-09-02T08:26:49.612000
               */
              createdAt?: string;
              /**
               * @description Meaningful label for results association. 
               * @example result_for_PID
               */
              name?: string;
              /**
               * @description Description of the result 
               * @example This is a result file for PID controller
               */
              description?: string;
              /**
               * @description Name of workspace. 
               * @example workspace
               */
              workspaceId?: string;
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteUploadedResultEntity: {
    /** Deletes the result with the specified ID */
    responses: {
      /** @description OK. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getCurrentUser: {
    /**
     * Gets data on the currently logged in user 
     * @description Returns the ID of the current user, which is used to create API keys, and the external IDs connected to it.
     */
    responses: {
      /** @description . */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The user ID. 
               * @example 2bb76154701c47c38d1950ea60d2c025
               */
              id: string;
              /** @description List of external IDs that are connected to this user ID. */
              externalUsers?: ({
                  /**
                   * @description ExternalID. 
                   * @example name@company.com
                   */
                  id?: string;
                })[];
              /**
               * @description The users license. If field is missing the user does not have a license. 
               * @example impact-pro 
               * @enum {string}
               */
              license?: "impact-pro" | "impact-base" | "impact-deployment";
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getAPIkeys: {
    /**
     * Gets information on the API keys belonging to a user 
     * @description Get information on the API keys belonging to the user by the given ID. The information includes the key ID and the creation time but not the secret key itself.
     */
    responses: {
      /** @description Information about existing API keys. */
      200: {
        content: {
          "application/json": {
            data?: {
              items?: ({
                  /**
                   * @description The ID of the key. 
                   * @example zPY1U0KuBP
                   */
                  id?: string;
                  /**
                   * @description Timestamp of when the key was created. 
                   * @example 1588016253
                   */
                  createdAt?: number;
                })[];
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  postAPIkey: {
    /**
     * Creates a new API key 
     * @description Creates a new API key belonging to the user with the given ID. The response contains a new API key which is the only time this key can be retrieved. They key must be safely stored by the recepient, as there is no way to retrieve it at a later point. A user may only have one API key at a time, so if it is lost or compromised, it must be deleted before a new one can be created. The API key can be used with the /login endpoint to log in. Each key has an ID to identify it when deleting it.
     */
    responses: {
      /** @description OK: A new API key has been created. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The API key ID. 
               * @example zPY1U0KuBP
               */
              id?: string;
              /**
               * @description The API key. 
               * @example secret-api-key
               */
              secret?: string;
              /**
               * @description The timestamp of when the key was created. 
               * @example 1588016253
               */
              created_at?: number;
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteAPIKey: {
    /**
     * Deletes an API key 
     * @description Deletes an API key with the given ID, belonging to a specified user.
     */
    parameters: {
        /**
         * @description ID of the user owning the key. 
         * @example 3ae546601b0d473db83bccee0ca27c7e
         */
        /**
         * @description ID of the API key. 
         * @example zPY1U0KuBP
         */
      path: {
        userId: string;
        keyId: string;
      };
    };
    responses: {
      /** @description OK: The API key was deleted. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  validateAPIKey: {
    /**
     * Validates an API key 
     * @description Validates an API key.
     */
    /** @description . */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description An API key to validate. 
           * @example secret-api-key
           */
          secret: string;
        };
      };
    };
    responses: {
      /** @description Information about the user who owns the API key. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The user ID of the owner of the key. 
               * @example 2bb76154701c47c38d1950ea60d2c025
               */
              id?: string;
            };
          };
        };
      };
      /** @description The provided API key is invalid. */
      400: {
        content: {
          "application/json": {
            error?: {
              /**
               * @description Error message describing what went wrong. 
               * @example The provided API key is not valid
               */
              message?: string;
              /**
               * @description Error code for identifying specific errors. 
               * @example 12035
               */
              code?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
}
